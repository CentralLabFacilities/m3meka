// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "actuator.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>

namespace {

const ::google::protobuf::Descriptor* M3ActuatorStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  M3ActuatorStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* M3ActuatorParam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  M3ActuatorParam_reflection_ = NULL;
const ::google::protobuf::Descriptor* M3ActuatorCommand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  M3ActuatorCommand_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ACTUATOR_MODE_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_actuator_2eproto() {
  protobuf_AddDesc_actuator_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "actuator.proto");
  GOOGLE_CHECK(file != NULL);
  M3ActuatorStatus_descriptor_ = file->message_type(0);
  static const int M3ActuatorStatus_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, motor_temp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, amp_temp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, current_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, torque_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, torquedot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, theta_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, thetadot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, thetadotdot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, torque_error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, pwm_cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, ambient_temp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, case_temp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, power_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, ext_temp_),
  };
  M3ActuatorStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      M3ActuatorStatus_descriptor_,
      M3ActuatorStatus::default_instance_,
      M3ActuatorStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(M3ActuatorStatus));
  M3ActuatorParam_descriptor_ = file->message_type(1);
  static const int M3ActuatorParam_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorParam, max_amp_temp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorParam, max_tq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorParam, min_tq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorParam, max_amp_current_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorParam, max_overload_time_),
  };
  M3ActuatorParam_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      M3ActuatorParam_descriptor_,
      M3ActuatorParam::default_instance_,
      M3ActuatorParam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorParam, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorParam, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(M3ActuatorParam));
  M3ActuatorCommand_descriptor_ = file->message_type(2);
  static const int M3ActuatorCommand_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorCommand, tq_desired_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorCommand, pwm_desired_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorCommand, ctrl_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorCommand, brake_off_),
  };
  M3ActuatorCommand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      M3ActuatorCommand_descriptor_,
      M3ActuatorCommand::default_instance_,
      M3ActuatorCommand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorCommand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(M3ActuatorCommand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(M3ActuatorCommand));
  ACTUATOR_MODE_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_actuator_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    M3ActuatorStatus_descriptor_, &M3ActuatorStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    M3ActuatorParam_descriptor_, &M3ActuatorParam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    M3ActuatorCommand_descriptor_, &M3ActuatorCommand::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_actuator_2eproto() {
  delete M3ActuatorStatus::default_instance_;
  delete M3ActuatorStatus_reflection_;
  delete M3ActuatorParam::default_instance_;
  delete M3ActuatorParam_reflection_;
  delete M3ActuatorCommand::default_instance_;
  delete M3ActuatorCommand_reflection_;
}

void protobuf_AddDesc_actuator_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_component_5fbase_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016actuator.proto\032\024component_base.proto\"\277"
    "\002\n\020M3ActuatorStatus\022\033\n\004base\030\001 \001(\0132\r.M3Ba"
    "seStatus\022\022\n\nmotor_temp\030\002 \001(\001\022\020\n\010amp_temp"
    "\030\003 \001(\001\022\017\n\007current\030\004 \001(\001\022\016\n\006torque\030\006 \001(\001\022"
    "\021\n\ttorquedot\030\007 \001(\001\022\r\n\005theta\030\010 \001(\001\022\020\n\010the"
    "tadot\030\t \001(\001\022\023\n\013thetadotdot\030\n \001(\001\022\024\n\014torq"
    "ue_error\030\013 \001(\001\022\017\n\007pwm_cmd\030\014 \001(\005\022\024\n\014ambie"
    "nt_temp\030\r \001(\001\022\021\n\tcase_temp\030\016 \001(\001\022\r\n\005powe"
    "r\030\020 \001(\001\022\r\n\005flags\030\021 \001(\005\022\020\n\010ext_temp\030\022 \001(\001"
    "\"{\n\017M3ActuatorParam\022\024\n\014max_amp_temp\030\001 \001("
    "\001\022\016\n\006max_tq\030\002 \001(\001\022\016\n\006min_tq\030\003 \001(\001\022\027\n\017max"
    "_amp_current\030\004 \001(\001\022\031\n\021max_overload_time\030"
    "\005 \001(\001\"r\n\021M3ActuatorCommand\022\022\n\ntq_desired"
    "\030\002 \001(\001\022\023\n\013pwm_desired\030\003 \001(\001\022!\n\tctrl_mode"
    "\030\004 \001(\0162\016.ACTUATOR_MODE\022\021\n\tbrake_off\030\005 \001("
    "\010*W\n\rACTUATOR_MODE\022\025\n\021ACTUATOR_MODE_OFF\020"
    "\000\022\025\n\021ACTUATOR_MODE_PWM\020\001\022\030\n\024ACTUATOR_MOD"
    "E_TORQUE\020\002B\002H\001", 694);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "actuator.proto", &protobuf_RegisterTypes);
  M3ActuatorStatus::default_instance_ = new M3ActuatorStatus();
  M3ActuatorParam::default_instance_ = new M3ActuatorParam();
  M3ActuatorCommand::default_instance_ = new M3ActuatorCommand();
  M3ActuatorStatus::default_instance_->InitAsDefaultInstance();
  M3ActuatorParam::default_instance_->InitAsDefaultInstance();
  M3ActuatorCommand::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_actuator_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_actuator_2eproto {
  StaticDescriptorInitializer_actuator_2eproto() {
    protobuf_AddDesc_actuator_2eproto();
  }
} static_descriptor_initializer_actuator_2eproto_;

const ::google::protobuf::EnumDescriptor* ACTUATOR_MODE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACTUATOR_MODE_descriptor_;
}
bool ACTUATOR_MODE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int M3ActuatorStatus::kBaseFieldNumber;
const int M3ActuatorStatus::kMotorTempFieldNumber;
const int M3ActuatorStatus::kAmpTempFieldNumber;
const int M3ActuatorStatus::kCurrentFieldNumber;
const int M3ActuatorStatus::kTorqueFieldNumber;
const int M3ActuatorStatus::kTorquedotFieldNumber;
const int M3ActuatorStatus::kThetaFieldNumber;
const int M3ActuatorStatus::kThetadotFieldNumber;
const int M3ActuatorStatus::kThetadotdotFieldNumber;
const int M3ActuatorStatus::kTorqueErrorFieldNumber;
const int M3ActuatorStatus::kPwmCmdFieldNumber;
const int M3ActuatorStatus::kAmbientTempFieldNumber;
const int M3ActuatorStatus::kCaseTempFieldNumber;
const int M3ActuatorStatus::kPowerFieldNumber;
const int M3ActuatorStatus::kFlagsFieldNumber;
const int M3ActuatorStatus::kExtTempFieldNumber;
#endif  // !_MSC_VER

M3ActuatorStatus::M3ActuatorStatus() {
  SharedCtor();
}

void M3ActuatorStatus::InitAsDefaultInstance() {
  base_ = const_cast< ::M3BaseStatus*>(&::M3BaseStatus::default_instance());
}

M3ActuatorStatus::M3ActuatorStatus(const M3ActuatorStatus& from) {
  SharedCtor();
  MergeFrom(from);
}

void M3ActuatorStatus::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  motor_temp_ = 0;
  amp_temp_ = 0;
  current_ = 0;
  torque_ = 0;
  torquedot_ = 0;
  theta_ = 0;
  thetadot_ = 0;
  thetadotdot_ = 0;
  torque_error_ = 0;
  pwm_cmd_ = 0;
  ambient_temp_ = 0;
  case_temp_ = 0;
  power_ = 0;
  flags_ = 0;
  ext_temp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

M3ActuatorStatus::~M3ActuatorStatus() {
  SharedDtor();
}

void M3ActuatorStatus::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
  }
}

const ::google::protobuf::Descriptor* M3ActuatorStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return M3ActuatorStatus_descriptor_;
}

const M3ActuatorStatus& M3ActuatorStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_actuator_2eproto();  return *default_instance_;
}

M3ActuatorStatus* M3ActuatorStatus::default_instance_ = NULL;

M3ActuatorStatus* M3ActuatorStatus::New() const {
  return new M3ActuatorStatus;
}

void M3ActuatorStatus::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (base_ != NULL) base_->::M3BaseStatus::Clear();
    }
    motor_temp_ = 0;
    amp_temp_ = 0;
    current_ = 0;
    torque_ = 0;
    torquedot_ = 0;
    theta_ = 0;
    thetadot_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    thetadotdot_ = 0;
    torque_error_ = 0;
    pwm_cmd_ = 0;
    ambient_temp_ = 0;
    case_temp_ = 0;
    power_ = 0;
    flags_ = 0;
    ext_temp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool M3ActuatorStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .M3BaseStatus base = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_base()));
        if (input->ExpectTag(17)) goto parse_motor_temp;
        break;
      }
      
      // optional double motor_temp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_motor_temp:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &motor_temp_));
        _set_bit(1);
        if (input->ExpectTag(25)) goto parse_amp_temp;
        break;
      }
      
      // optional double amp_temp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_amp_temp:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &amp_temp_));
        _set_bit(2);
        if (input->ExpectTag(33)) goto parse_current;
        break;
      }
      
      // optional double current = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_current:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &current_));
        _set_bit(3);
        if (input->ExpectTag(49)) goto parse_torque;
        break;
      }
      
      // optional double torque = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_torque:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &torque_));
        _set_bit(4);
        if (input->ExpectTag(57)) goto parse_torquedot;
        break;
      }
      
      // optional double torquedot = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_torquedot:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &torquedot_));
        _set_bit(5);
        if (input->ExpectTag(65)) goto parse_theta;
        break;
      }
      
      // optional double theta = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_theta:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &theta_));
        _set_bit(6);
        if (input->ExpectTag(73)) goto parse_thetadot;
        break;
      }
      
      // optional double thetadot = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_thetadot:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &thetadot_));
        _set_bit(7);
        if (input->ExpectTag(81)) goto parse_thetadotdot;
        break;
      }
      
      // optional double thetadotdot = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_thetadotdot:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &thetadotdot_));
        _set_bit(8);
        if (input->ExpectTag(89)) goto parse_torque_error;
        break;
      }
      
      // optional double torque_error = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_torque_error:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &torque_error_));
        _set_bit(9);
        if (input->ExpectTag(96)) goto parse_pwm_cmd;
        break;
      }
      
      // optional int32 pwm_cmd = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_pwm_cmd:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &pwm_cmd_));
        _set_bit(10);
        if (input->ExpectTag(105)) goto parse_ambient_temp;
        break;
      }
      
      // optional double ambient_temp = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_ambient_temp:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &ambient_temp_));
        _set_bit(11);
        if (input->ExpectTag(113)) goto parse_case_temp;
        break;
      }
      
      // optional double case_temp = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_case_temp:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &case_temp_));
        _set_bit(12);
        if (input->ExpectTag(129)) goto parse_power;
        break;
      }
      
      // optional double power = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_power:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &power_));
        _set_bit(13);
        if (input->ExpectTag(136)) goto parse_flags;
        break;
      }
      
      // optional int32 flags = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_flags:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &flags_));
        _set_bit(14);
        if (input->ExpectTag(145)) goto parse_ext_temp;
        break;
      }
      
      // optional double ext_temp = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_ext_temp:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &ext_temp_));
        _set_bit(15);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void M3ActuatorStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    M3ActuatorStatus::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional .M3BaseStatus base = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->base(), output);
  }
  
  // optional double motor_temp = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->motor_temp(), output);
  }
  
  // optional double amp_temp = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->amp_temp(), output);
  }
  
  // optional double current = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->current(), output);
  }
  
  // optional double torque = 6;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->torque(), output);
  }
  
  // optional double torquedot = 7;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->torquedot(), output);
  }
  
  // optional double theta = 8;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->theta(), output);
  }
  
  // optional double thetadot = 9;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->thetadot(), output);
  }
  
  // optional double thetadotdot = 10;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->thetadotdot(), output);
  }
  
  // optional double torque_error = 11;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->torque_error(), output);
  }
  
  // optional int32 pwm_cmd = 12;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->pwm_cmd(), output);
  }
  
  // optional double ambient_temp = 13;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->ambient_temp(), output);
  }
  
  // optional double case_temp = 14;
  if (_has_bit(12)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->case_temp(), output);
  }
  
  // optional double power = 16;
  if (_has_bit(13)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(16, this->power(), output);
  }
  
  // optional int32 flags = 17;
  if (_has_bit(14)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->flags(), output);
  }
  
  // optional double ext_temp = 18;
  if (_has_bit(15)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->ext_temp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* M3ActuatorStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .M3BaseStatus base = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->base(), target);
  }
  
  // optional double motor_temp = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->motor_temp(), target);
  }
  
  // optional double amp_temp = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->amp_temp(), target);
  }
  
  // optional double current = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->current(), target);
  }
  
  // optional double torque = 6;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->torque(), target);
  }
  
  // optional double torquedot = 7;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->torquedot(), target);
  }
  
  // optional double theta = 8;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->theta(), target);
  }
  
  // optional double thetadot = 9;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->thetadot(), target);
  }
  
  // optional double thetadotdot = 10;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->thetadotdot(), target);
  }
  
  // optional double torque_error = 11;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->torque_error(), target);
  }
  
  // optional int32 pwm_cmd = 12;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->pwm_cmd(), target);
  }
  
  // optional double ambient_temp = 13;
  if (_has_bit(11)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->ambient_temp(), target);
  }
  
  // optional double case_temp = 14;
  if (_has_bit(12)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->case_temp(), target);
  }
  
  // optional double power = 16;
  if (_has_bit(13)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(16, this->power(), target);
  }
  
  // optional int32 flags = 17;
  if (_has_bit(14)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->flags(), target);
  }
  
  // optional double ext_temp = 18;
  if (_has_bit(15)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->ext_temp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int M3ActuatorStatus::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .M3BaseStatus base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }
    
    // optional double motor_temp = 2;
    if (has_motor_temp()) {
      total_size += 1 + 8;
    }
    
    // optional double amp_temp = 3;
    if (has_amp_temp()) {
      total_size += 1 + 8;
    }
    
    // optional double current = 4;
    if (has_current()) {
      total_size += 1 + 8;
    }
    
    // optional double torque = 6;
    if (has_torque()) {
      total_size += 1 + 8;
    }
    
    // optional double torquedot = 7;
    if (has_torquedot()) {
      total_size += 1 + 8;
    }
    
    // optional double theta = 8;
    if (has_theta()) {
      total_size += 1 + 8;
    }
    
    // optional double thetadot = 9;
    if (has_thetadot()) {
      total_size += 1 + 8;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double thetadotdot = 10;
    if (has_thetadotdot()) {
      total_size += 1 + 8;
    }
    
    // optional double torque_error = 11;
    if (has_torque_error()) {
      total_size += 1 + 8;
    }
    
    // optional int32 pwm_cmd = 12;
    if (has_pwm_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pwm_cmd());
    }
    
    // optional double ambient_temp = 13;
    if (has_ambient_temp()) {
      total_size += 1 + 8;
    }
    
    // optional double case_temp = 14;
    if (has_case_temp()) {
      total_size += 1 + 8;
    }
    
    // optional double power = 16;
    if (has_power()) {
      total_size += 2 + 8;
    }
    
    // optional int32 flags = 17;
    if (has_flags()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->flags());
    }
    
    // optional double ext_temp = 18;
    if (has_ext_temp()) {
      total_size += 2 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void M3ActuatorStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const M3ActuatorStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const M3ActuatorStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void M3ActuatorStatus::MergeFrom(const M3ActuatorStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_base()->::M3BaseStatus::MergeFrom(from.base());
    }
    if (from._has_bit(1)) {
      set_motor_temp(from.motor_temp());
    }
    if (from._has_bit(2)) {
      set_amp_temp(from.amp_temp());
    }
    if (from._has_bit(3)) {
      set_current(from.current());
    }
    if (from._has_bit(4)) {
      set_torque(from.torque());
    }
    if (from._has_bit(5)) {
      set_torquedot(from.torquedot());
    }
    if (from._has_bit(6)) {
      set_theta(from.theta());
    }
    if (from._has_bit(7)) {
      set_thetadot(from.thetadot());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_thetadotdot(from.thetadotdot());
    }
    if (from._has_bit(9)) {
      set_torque_error(from.torque_error());
    }
    if (from._has_bit(10)) {
      set_pwm_cmd(from.pwm_cmd());
    }
    if (from._has_bit(11)) {
      set_ambient_temp(from.ambient_temp());
    }
    if (from._has_bit(12)) {
      set_case_temp(from.case_temp());
    }
    if (from._has_bit(13)) {
      set_power(from.power());
    }
    if (from._has_bit(14)) {
      set_flags(from.flags());
    }
    if (from._has_bit(15)) {
      set_ext_temp(from.ext_temp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void M3ActuatorStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void M3ActuatorStatus::CopyFrom(const M3ActuatorStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool M3ActuatorStatus::IsInitialized() const {
  
  return true;
}

void M3ActuatorStatus::Swap(M3ActuatorStatus* other) {
  if (other != this) {
    std::swap(base_, other->base_);
    std::swap(motor_temp_, other->motor_temp_);
    std::swap(amp_temp_, other->amp_temp_);
    std::swap(current_, other->current_);
    std::swap(torque_, other->torque_);
    std::swap(torquedot_, other->torquedot_);
    std::swap(theta_, other->theta_);
    std::swap(thetadot_, other->thetadot_);
    std::swap(thetadotdot_, other->thetadotdot_);
    std::swap(torque_error_, other->torque_error_);
    std::swap(pwm_cmd_, other->pwm_cmd_);
    std::swap(ambient_temp_, other->ambient_temp_);
    std::swap(case_temp_, other->case_temp_);
    std::swap(power_, other->power_);
    std::swap(flags_, other->flags_);
    std::swap(ext_temp_, other->ext_temp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata M3ActuatorStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = M3ActuatorStatus_descriptor_;
  metadata.reflection = M3ActuatorStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int M3ActuatorParam::kMaxAmpTempFieldNumber;
const int M3ActuatorParam::kMaxTqFieldNumber;
const int M3ActuatorParam::kMinTqFieldNumber;
const int M3ActuatorParam::kMaxAmpCurrentFieldNumber;
const int M3ActuatorParam::kMaxOverloadTimeFieldNumber;
#endif  // !_MSC_VER

M3ActuatorParam::M3ActuatorParam() {
  SharedCtor();
}

void M3ActuatorParam::InitAsDefaultInstance() {
}

M3ActuatorParam::M3ActuatorParam(const M3ActuatorParam& from) {
  SharedCtor();
  MergeFrom(from);
}

void M3ActuatorParam::SharedCtor() {
  _cached_size_ = 0;
  max_amp_temp_ = 0;
  max_tq_ = 0;
  min_tq_ = 0;
  max_amp_current_ = 0;
  max_overload_time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

M3ActuatorParam::~M3ActuatorParam() {
  SharedDtor();
}

void M3ActuatorParam::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* M3ActuatorParam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return M3ActuatorParam_descriptor_;
}

const M3ActuatorParam& M3ActuatorParam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_actuator_2eproto();  return *default_instance_;
}

M3ActuatorParam* M3ActuatorParam::default_instance_ = NULL;

M3ActuatorParam* M3ActuatorParam::New() const {
  return new M3ActuatorParam;
}

void M3ActuatorParam::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    max_amp_temp_ = 0;
    max_tq_ = 0;
    min_tq_ = 0;
    max_amp_current_ = 0;
    max_overload_time_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool M3ActuatorParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double max_amp_temp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &max_amp_temp_));
        _set_bit(0);
        if (input->ExpectTag(17)) goto parse_max_tq;
        break;
      }
      
      // optional double max_tq = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_max_tq:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &max_tq_));
        _set_bit(1);
        if (input->ExpectTag(25)) goto parse_min_tq;
        break;
      }
      
      // optional double min_tq = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_min_tq:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &min_tq_));
        _set_bit(2);
        if (input->ExpectTag(33)) goto parse_max_amp_current;
        break;
      }
      
      // optional double max_amp_current = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_max_amp_current:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &max_amp_current_));
        _set_bit(3);
        if (input->ExpectTag(41)) goto parse_max_overload_time;
        break;
      }
      
      // optional double max_overload_time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_max_overload_time:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &max_overload_time_));
        _set_bit(4);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void M3ActuatorParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    M3ActuatorParam::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional double max_amp_temp = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->max_amp_temp(), output);
  }
  
  // optional double max_tq = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->max_tq(), output);
  }
  
  // optional double min_tq = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->min_tq(), output);
  }
  
  // optional double max_amp_current = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->max_amp_current(), output);
  }
  
  // optional double max_overload_time = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->max_overload_time(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* M3ActuatorParam::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional double max_amp_temp = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->max_amp_temp(), target);
  }
  
  // optional double max_tq = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->max_tq(), target);
  }
  
  // optional double min_tq = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->min_tq(), target);
  }
  
  // optional double max_amp_current = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->max_amp_current(), target);
  }
  
  // optional double max_overload_time = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->max_overload_time(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int M3ActuatorParam::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double max_amp_temp = 1;
    if (has_max_amp_temp()) {
      total_size += 1 + 8;
    }
    
    // optional double max_tq = 2;
    if (has_max_tq()) {
      total_size += 1 + 8;
    }
    
    // optional double min_tq = 3;
    if (has_min_tq()) {
      total_size += 1 + 8;
    }
    
    // optional double max_amp_current = 4;
    if (has_max_amp_current()) {
      total_size += 1 + 8;
    }
    
    // optional double max_overload_time = 5;
    if (has_max_overload_time()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void M3ActuatorParam::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const M3ActuatorParam* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const M3ActuatorParam*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void M3ActuatorParam::MergeFrom(const M3ActuatorParam& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_max_amp_temp(from.max_amp_temp());
    }
    if (from._has_bit(1)) {
      set_max_tq(from.max_tq());
    }
    if (from._has_bit(2)) {
      set_min_tq(from.min_tq());
    }
    if (from._has_bit(3)) {
      set_max_amp_current(from.max_amp_current());
    }
    if (from._has_bit(4)) {
      set_max_overload_time(from.max_overload_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void M3ActuatorParam::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void M3ActuatorParam::CopyFrom(const M3ActuatorParam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool M3ActuatorParam::IsInitialized() const {
  
  return true;
}

void M3ActuatorParam::Swap(M3ActuatorParam* other) {
  if (other != this) {
    std::swap(max_amp_temp_, other->max_amp_temp_);
    std::swap(max_tq_, other->max_tq_);
    std::swap(min_tq_, other->min_tq_);
    std::swap(max_amp_current_, other->max_amp_current_);
    std::swap(max_overload_time_, other->max_overload_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata M3ActuatorParam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = M3ActuatorParam_descriptor_;
  metadata.reflection = M3ActuatorParam_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int M3ActuatorCommand::kTqDesiredFieldNumber;
const int M3ActuatorCommand::kPwmDesiredFieldNumber;
const int M3ActuatorCommand::kCtrlModeFieldNumber;
const int M3ActuatorCommand::kBrakeOffFieldNumber;
#endif  // !_MSC_VER

M3ActuatorCommand::M3ActuatorCommand() {
  SharedCtor();
}

void M3ActuatorCommand::InitAsDefaultInstance() {
}

M3ActuatorCommand::M3ActuatorCommand(const M3ActuatorCommand& from) {
  SharedCtor();
  MergeFrom(from);
}

void M3ActuatorCommand::SharedCtor() {
  _cached_size_ = 0;
  tq_desired_ = 0;
  pwm_desired_ = 0;
  ctrl_mode_ = 0;
  brake_off_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

M3ActuatorCommand::~M3ActuatorCommand() {
  SharedDtor();
}

void M3ActuatorCommand::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* M3ActuatorCommand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return M3ActuatorCommand_descriptor_;
}

const M3ActuatorCommand& M3ActuatorCommand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_actuator_2eproto();  return *default_instance_;
}

M3ActuatorCommand* M3ActuatorCommand::default_instance_ = NULL;

M3ActuatorCommand* M3ActuatorCommand::New() const {
  return new M3ActuatorCommand;
}

void M3ActuatorCommand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tq_desired_ = 0;
    pwm_desired_ = 0;
    ctrl_mode_ = 0;
    brake_off_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool M3ActuatorCommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double tq_desired = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &tq_desired_));
        _set_bit(0);
        if (input->ExpectTag(25)) goto parse_pwm_desired;
        break;
      }
      
      // optional double pwm_desired = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_pwm_desired:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &pwm_desired_));
        _set_bit(1);
        if (input->ExpectTag(32)) goto parse_ctrl_mode;
        break;
      }
      
      // optional .ACTUATOR_MODE ctrl_mode = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_ctrl_mode:
        int value;
        DO_(::google::protobuf::internal::WireFormatLite::ReadEnum(input, &value));
        if (ACTUATOR_MODE_IsValid(value)) {
          set_ctrl_mode(static_cast< ACTUATOR_MODE >(value));
        } else {
          mutable_unknown_fields()->AddVarint(4, value);
        }
        if (input->ExpectTag(40)) goto parse_brake_off;
        break;
      }
      
      // optional bool brake_off = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_brake_off:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &brake_off_));
        _set_bit(3);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void M3ActuatorCommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    M3ActuatorCommand::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional double tq_desired = 2;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->tq_desired(), output);
  }
  
  // optional double pwm_desired = 3;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->pwm_desired(), output);
  }
  
  // optional .ACTUATOR_MODE ctrl_mode = 4;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->ctrl_mode(), output);
  }
  
  // optional bool brake_off = 5;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->brake_off(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* M3ActuatorCommand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional double tq_desired = 2;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->tq_desired(), target);
  }
  
  // optional double pwm_desired = 3;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->pwm_desired(), target);
  }
  
  // optional .ACTUATOR_MODE ctrl_mode = 4;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->ctrl_mode(), target);
  }
  
  // optional bool brake_off = 5;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->brake_off(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int M3ActuatorCommand::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double tq_desired = 2;
    if (has_tq_desired()) {
      total_size += 1 + 8;
    }
    
    // optional double pwm_desired = 3;
    if (has_pwm_desired()) {
      total_size += 1 + 8;
    }
    
    // optional .ACTUATOR_MODE ctrl_mode = 4;
    if (has_ctrl_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ctrl_mode());
    }
    
    // optional bool brake_off = 5;
    if (has_brake_off()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void M3ActuatorCommand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const M3ActuatorCommand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const M3ActuatorCommand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void M3ActuatorCommand::MergeFrom(const M3ActuatorCommand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_tq_desired(from.tq_desired());
    }
    if (from._has_bit(1)) {
      set_pwm_desired(from.pwm_desired());
    }
    if (from._has_bit(2)) {
      set_ctrl_mode(from.ctrl_mode());
    }
    if (from._has_bit(3)) {
      set_brake_off(from.brake_off());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void M3ActuatorCommand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void M3ActuatorCommand::CopyFrom(const M3ActuatorCommand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool M3ActuatorCommand::IsInitialized() const {
  
  return true;
}

void M3ActuatorCommand::Swap(M3ActuatorCommand* other) {
  if (other != this) {
    std::swap(tq_desired_, other->tq_desired_);
    std::swap(pwm_desired_, other->pwm_desired_);
    std::swap(ctrl_mode_, other->ctrl_mode_);
    std::swap(brake_off_, other->brake_off_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata M3ActuatorCommand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = M3ActuatorCommand_descriptor_;
  metadata.reflection = M3ActuatorCommand_reflection_;
  return metadata;
}

