// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_actuator_2eproto__INCLUDED
#define PROTOBUF_actuator_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "component_base.pb.h"

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_actuator_2eproto();
void protobuf_AssignDesc_actuator_2eproto();
void protobuf_ShutdownFile_actuator_2eproto();

class M3ActuatorStatus;
class M3ActuatorParam;
class M3ActuatorCommand;

enum ACTUATOR_MODE {
  ACTUATOR_MODE_OFF = 0,
  ACTUATOR_MODE_PWM = 1,
  ACTUATOR_MODE_TORQUE = 2
};
bool ACTUATOR_MODE_IsValid(int value);
const ACTUATOR_MODE ACTUATOR_MODE_MIN = ACTUATOR_MODE_OFF;
const ACTUATOR_MODE ACTUATOR_MODE_MAX = ACTUATOR_MODE_TORQUE;

const ::google::protobuf::EnumDescriptor* ACTUATOR_MODE_descriptor();
inline const ::std::string& ACTUATOR_MODE_Name(ACTUATOR_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACTUATOR_MODE_descriptor(), value);
}
inline bool ACTUATOR_MODE_Parse(
    const ::std::string& name, ACTUATOR_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACTUATOR_MODE>(
    ACTUATOR_MODE_descriptor(), name, value);
}
// ===================================================================

class M3ActuatorStatus : public ::google::protobuf::Message {
 public:
  M3ActuatorStatus();
  virtual ~M3ActuatorStatus();
  
  M3ActuatorStatus(const M3ActuatorStatus& from);
  
  inline M3ActuatorStatus& operator=(const M3ActuatorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorStatus& default_instance();
  void Swap(M3ActuatorStatus* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorStatus& from);
  void MergeFrom(const M3ActuatorStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .M3BaseStatus base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::M3BaseStatus& base() const;
  inline ::M3BaseStatus* mutable_base();
  
  // optional double motor_temp = 2;
  inline bool has_motor_temp() const;
  inline void clear_motor_temp();
  static const int kMotorTempFieldNumber = 2;
  inline double motor_temp() const;
  inline void set_motor_temp(double value);
  
  // optional double amp_temp = 3;
  inline bool has_amp_temp() const;
  inline void clear_amp_temp();
  static const int kAmpTempFieldNumber = 3;
  inline double amp_temp() const;
  inline void set_amp_temp(double value);
  
  // optional double current = 4;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 4;
  inline double current() const;
  inline void set_current(double value);
  
  // optional double torque = 6;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 6;
  inline double torque() const;
  inline void set_torque(double value);
  
  // optional double torquedot = 7;
  inline bool has_torquedot() const;
  inline void clear_torquedot();
  static const int kTorquedotFieldNumber = 7;
  inline double torquedot() const;
  inline void set_torquedot(double value);
  
  // optional double theta = 8;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 8;
  inline double theta() const;
  inline void set_theta(double value);
  
  // optional double thetadot = 9;
  inline bool has_thetadot() const;
  inline void clear_thetadot();
  static const int kThetadotFieldNumber = 9;
  inline double thetadot() const;
  inline void set_thetadot(double value);
  
  // optional double thetadotdot = 10;
  inline bool has_thetadotdot() const;
  inline void clear_thetadotdot();
  static const int kThetadotdotFieldNumber = 10;
  inline double thetadotdot() const;
  inline void set_thetadotdot(double value);
  
  // optional double torque_error = 11;
  inline bool has_torque_error() const;
  inline void clear_torque_error();
  static const int kTorqueErrorFieldNumber = 11;
  inline double torque_error() const;
  inline void set_torque_error(double value);
  
  // optional int32 pwm_cmd = 12;
  inline bool has_pwm_cmd() const;
  inline void clear_pwm_cmd();
  static const int kPwmCmdFieldNumber = 12;
  inline ::google::protobuf::int32 pwm_cmd() const;
  inline void set_pwm_cmd(::google::protobuf::int32 value);
  
  // optional double ambient_temp = 13;
  inline bool has_ambient_temp() const;
  inline void clear_ambient_temp();
  static const int kAmbientTempFieldNumber = 13;
  inline double ambient_temp() const;
  inline void set_ambient_temp(double value);
  
  // optional double case_temp = 14;
  inline bool has_case_temp() const;
  inline void clear_case_temp();
  static const int kCaseTempFieldNumber = 14;
  inline double case_temp() const;
  inline void set_case_temp(double value);
  
  // optional double power = 16;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 16;
  inline double power() const;
  inline void set_power(double value);
  
  // optional int32 flags = 17;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 17;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);
  
  // optional double ext_temp = 18;
  inline bool has_ext_temp() const;
  inline void clear_ext_temp();
  static const int kExtTempFieldNumber = 18;
  inline double ext_temp() const;
  inline void set_ext_temp(double value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::M3BaseStatus* base_;
  double motor_temp_;
  double amp_temp_;
  double current_;
  double torque_;
  double torquedot_;
  double theta_;
  double thetadot_;
  double thetadotdot_;
  double torque_error_;
  ::google::protobuf::int32 pwm_cmd_;
  double ambient_temp_;
  double case_temp_;
  double power_;
  ::google::protobuf::int32 flags_;
  double ext_temp_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static M3ActuatorStatus* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorParam : public ::google::protobuf::Message {
 public:
  M3ActuatorParam();
  virtual ~M3ActuatorParam();
  
  M3ActuatorParam(const M3ActuatorParam& from);
  
  inline M3ActuatorParam& operator=(const M3ActuatorParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorParam& default_instance();
  void Swap(M3ActuatorParam* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorParam& from);
  void MergeFrom(const M3ActuatorParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double max_amp_temp = 1;
  inline bool has_max_amp_temp() const;
  inline void clear_max_amp_temp();
  static const int kMaxAmpTempFieldNumber = 1;
  inline double max_amp_temp() const;
  inline void set_max_amp_temp(double value);
  
  // optional double max_tq = 2;
  inline bool has_max_tq() const;
  inline void clear_max_tq();
  static const int kMaxTqFieldNumber = 2;
  inline double max_tq() const;
  inline void set_max_tq(double value);
  
  // optional double min_tq = 3;
  inline bool has_min_tq() const;
  inline void clear_min_tq();
  static const int kMinTqFieldNumber = 3;
  inline double min_tq() const;
  inline void set_min_tq(double value);
  
  // optional double max_amp_current = 4;
  inline bool has_max_amp_current() const;
  inline void clear_max_amp_current();
  static const int kMaxAmpCurrentFieldNumber = 4;
  inline double max_amp_current() const;
  inline void set_max_amp_current(double value);
  
  // optional double max_overload_time = 5;
  inline bool has_max_overload_time() const;
  inline void clear_max_overload_time();
  static const int kMaxOverloadTimeFieldNumber = 5;
  inline double max_overload_time() const;
  inline void set_max_overload_time(double value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double max_amp_temp_;
  double max_tq_;
  double min_tq_;
  double max_amp_current_;
  double max_overload_time_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static M3ActuatorParam* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorCommand : public ::google::protobuf::Message {
 public:
  M3ActuatorCommand();
  virtual ~M3ActuatorCommand();
  
  M3ActuatorCommand(const M3ActuatorCommand& from);
  
  inline M3ActuatorCommand& operator=(const M3ActuatorCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorCommand& default_instance();
  void Swap(M3ActuatorCommand* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorCommand& from);
  void MergeFrom(const M3ActuatorCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double tq_desired = 2;
  inline bool has_tq_desired() const;
  inline void clear_tq_desired();
  static const int kTqDesiredFieldNumber = 2;
  inline double tq_desired() const;
  inline void set_tq_desired(double value);
  
  // optional double pwm_desired = 3;
  inline bool has_pwm_desired() const;
  inline void clear_pwm_desired();
  static const int kPwmDesiredFieldNumber = 3;
  inline double pwm_desired() const;
  inline void set_pwm_desired(double value);
  
  // optional .ACTUATOR_MODE ctrl_mode = 4;
  inline bool has_ctrl_mode() const;
  inline void clear_ctrl_mode();
  static const int kCtrlModeFieldNumber = 4;
  inline ACTUATOR_MODE ctrl_mode() const;
  inline void set_ctrl_mode(ACTUATOR_MODE value);
  
  // optional bool brake_off = 5;
  inline bool has_brake_off() const;
  inline void clear_brake_off();
  static const int kBrakeOffFieldNumber = 5;
  inline bool brake_off() const;
  inline void set_brake_off(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double tq_desired_;
  double pwm_desired_;
  int ctrl_mode_;
  bool brake_off_;
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static M3ActuatorCommand* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// M3ActuatorStatus

// optional .M3BaseStatus base = 1;
inline bool M3ActuatorStatus::has_base() const {
  return _has_bit(0);
}
inline void M3ActuatorStatus::clear_base() {
  if (base_ != NULL) base_->::M3BaseStatus::Clear();
  _clear_bit(0);
}
inline const ::M3BaseStatus& M3ActuatorStatus::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::M3BaseStatus* M3ActuatorStatus::mutable_base() {
  _set_bit(0);
  if (base_ == NULL) base_ = new ::M3BaseStatus;
  return base_;
}

// optional double motor_temp = 2;
inline bool M3ActuatorStatus::has_motor_temp() const {
  return _has_bit(1);
}
inline void M3ActuatorStatus::clear_motor_temp() {
  motor_temp_ = 0;
  _clear_bit(1);
}
inline double M3ActuatorStatus::motor_temp() const {
  return motor_temp_;
}
inline void M3ActuatorStatus::set_motor_temp(double value) {
  _set_bit(1);
  motor_temp_ = value;
}

// optional double amp_temp = 3;
inline bool M3ActuatorStatus::has_amp_temp() const {
  return _has_bit(2);
}
inline void M3ActuatorStatus::clear_amp_temp() {
  amp_temp_ = 0;
  _clear_bit(2);
}
inline double M3ActuatorStatus::amp_temp() const {
  return amp_temp_;
}
inline void M3ActuatorStatus::set_amp_temp(double value) {
  _set_bit(2);
  amp_temp_ = value;
}

// optional double current = 4;
inline bool M3ActuatorStatus::has_current() const {
  return _has_bit(3);
}
inline void M3ActuatorStatus::clear_current() {
  current_ = 0;
  _clear_bit(3);
}
inline double M3ActuatorStatus::current() const {
  return current_;
}
inline void M3ActuatorStatus::set_current(double value) {
  _set_bit(3);
  current_ = value;
}

// optional double torque = 6;
inline bool M3ActuatorStatus::has_torque() const {
  return _has_bit(4);
}
inline void M3ActuatorStatus::clear_torque() {
  torque_ = 0;
  _clear_bit(4);
}
inline double M3ActuatorStatus::torque() const {
  return torque_;
}
inline void M3ActuatorStatus::set_torque(double value) {
  _set_bit(4);
  torque_ = value;
}

// optional double torquedot = 7;
inline bool M3ActuatorStatus::has_torquedot() const {
  return _has_bit(5);
}
inline void M3ActuatorStatus::clear_torquedot() {
  torquedot_ = 0;
  _clear_bit(5);
}
inline double M3ActuatorStatus::torquedot() const {
  return torquedot_;
}
inline void M3ActuatorStatus::set_torquedot(double value) {
  _set_bit(5);
  torquedot_ = value;
}

// optional double theta = 8;
inline bool M3ActuatorStatus::has_theta() const {
  return _has_bit(6);
}
inline void M3ActuatorStatus::clear_theta() {
  theta_ = 0;
  _clear_bit(6);
}
inline double M3ActuatorStatus::theta() const {
  return theta_;
}
inline void M3ActuatorStatus::set_theta(double value) {
  _set_bit(6);
  theta_ = value;
}

// optional double thetadot = 9;
inline bool M3ActuatorStatus::has_thetadot() const {
  return _has_bit(7);
}
inline void M3ActuatorStatus::clear_thetadot() {
  thetadot_ = 0;
  _clear_bit(7);
}
inline double M3ActuatorStatus::thetadot() const {
  return thetadot_;
}
inline void M3ActuatorStatus::set_thetadot(double value) {
  _set_bit(7);
  thetadot_ = value;
}

// optional double thetadotdot = 10;
inline bool M3ActuatorStatus::has_thetadotdot() const {
  return _has_bit(8);
}
inline void M3ActuatorStatus::clear_thetadotdot() {
  thetadotdot_ = 0;
  _clear_bit(8);
}
inline double M3ActuatorStatus::thetadotdot() const {
  return thetadotdot_;
}
inline void M3ActuatorStatus::set_thetadotdot(double value) {
  _set_bit(8);
  thetadotdot_ = value;
}

// optional double torque_error = 11;
inline bool M3ActuatorStatus::has_torque_error() const {
  return _has_bit(9);
}
inline void M3ActuatorStatus::clear_torque_error() {
  torque_error_ = 0;
  _clear_bit(9);
}
inline double M3ActuatorStatus::torque_error() const {
  return torque_error_;
}
inline void M3ActuatorStatus::set_torque_error(double value) {
  _set_bit(9);
  torque_error_ = value;
}

// optional int32 pwm_cmd = 12;
inline bool M3ActuatorStatus::has_pwm_cmd() const {
  return _has_bit(10);
}
inline void M3ActuatorStatus::clear_pwm_cmd() {
  pwm_cmd_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 M3ActuatorStatus::pwm_cmd() const {
  return pwm_cmd_;
}
inline void M3ActuatorStatus::set_pwm_cmd(::google::protobuf::int32 value) {
  _set_bit(10);
  pwm_cmd_ = value;
}

// optional double ambient_temp = 13;
inline bool M3ActuatorStatus::has_ambient_temp() const {
  return _has_bit(11);
}
inline void M3ActuatorStatus::clear_ambient_temp() {
  ambient_temp_ = 0;
  _clear_bit(11);
}
inline double M3ActuatorStatus::ambient_temp() const {
  return ambient_temp_;
}
inline void M3ActuatorStatus::set_ambient_temp(double value) {
  _set_bit(11);
  ambient_temp_ = value;
}

// optional double case_temp = 14;
inline bool M3ActuatorStatus::has_case_temp() const {
  return _has_bit(12);
}
inline void M3ActuatorStatus::clear_case_temp() {
  case_temp_ = 0;
  _clear_bit(12);
}
inline double M3ActuatorStatus::case_temp() const {
  return case_temp_;
}
inline void M3ActuatorStatus::set_case_temp(double value) {
  _set_bit(12);
  case_temp_ = value;
}

// optional double power = 16;
inline bool M3ActuatorStatus::has_power() const {
  return _has_bit(13);
}
inline void M3ActuatorStatus::clear_power() {
  power_ = 0;
  _clear_bit(13);
}
inline double M3ActuatorStatus::power() const {
  return power_;
}
inline void M3ActuatorStatus::set_power(double value) {
  _set_bit(13);
  power_ = value;
}

// optional int32 flags = 17;
inline bool M3ActuatorStatus::has_flags() const {
  return _has_bit(14);
}
inline void M3ActuatorStatus::clear_flags() {
  flags_ = 0;
  _clear_bit(14);
}
inline ::google::protobuf::int32 M3ActuatorStatus::flags() const {
  return flags_;
}
inline void M3ActuatorStatus::set_flags(::google::protobuf::int32 value) {
  _set_bit(14);
  flags_ = value;
}

// optional double ext_temp = 18;
inline bool M3ActuatorStatus::has_ext_temp() const {
  return _has_bit(15);
}
inline void M3ActuatorStatus::clear_ext_temp() {
  ext_temp_ = 0;
  _clear_bit(15);
}
inline double M3ActuatorStatus::ext_temp() const {
  return ext_temp_;
}
inline void M3ActuatorStatus::set_ext_temp(double value) {
  _set_bit(15);
  ext_temp_ = value;
}

// -------------------------------------------------------------------

// M3ActuatorParam

// optional double max_amp_temp = 1;
inline bool M3ActuatorParam::has_max_amp_temp() const {
  return _has_bit(0);
}
inline void M3ActuatorParam::clear_max_amp_temp() {
  max_amp_temp_ = 0;
  _clear_bit(0);
}
inline double M3ActuatorParam::max_amp_temp() const {
  return max_amp_temp_;
}
inline void M3ActuatorParam::set_max_amp_temp(double value) {
  _set_bit(0);
  max_amp_temp_ = value;
}

// optional double max_tq = 2;
inline bool M3ActuatorParam::has_max_tq() const {
  return _has_bit(1);
}
inline void M3ActuatorParam::clear_max_tq() {
  max_tq_ = 0;
  _clear_bit(1);
}
inline double M3ActuatorParam::max_tq() const {
  return max_tq_;
}
inline void M3ActuatorParam::set_max_tq(double value) {
  _set_bit(1);
  max_tq_ = value;
}

// optional double min_tq = 3;
inline bool M3ActuatorParam::has_min_tq() const {
  return _has_bit(2);
}
inline void M3ActuatorParam::clear_min_tq() {
  min_tq_ = 0;
  _clear_bit(2);
}
inline double M3ActuatorParam::min_tq() const {
  return min_tq_;
}
inline void M3ActuatorParam::set_min_tq(double value) {
  _set_bit(2);
  min_tq_ = value;
}

// optional double max_amp_current = 4;
inline bool M3ActuatorParam::has_max_amp_current() const {
  return _has_bit(3);
}
inline void M3ActuatorParam::clear_max_amp_current() {
  max_amp_current_ = 0;
  _clear_bit(3);
}
inline double M3ActuatorParam::max_amp_current() const {
  return max_amp_current_;
}
inline void M3ActuatorParam::set_max_amp_current(double value) {
  _set_bit(3);
  max_amp_current_ = value;
}

// optional double max_overload_time = 5;
inline bool M3ActuatorParam::has_max_overload_time() const {
  return _has_bit(4);
}
inline void M3ActuatorParam::clear_max_overload_time() {
  max_overload_time_ = 0;
  _clear_bit(4);
}
inline double M3ActuatorParam::max_overload_time() const {
  return max_overload_time_;
}
inline void M3ActuatorParam::set_max_overload_time(double value) {
  _set_bit(4);
  max_overload_time_ = value;
}

// -------------------------------------------------------------------

// M3ActuatorCommand

// optional double tq_desired = 2;
inline bool M3ActuatorCommand::has_tq_desired() const {
  return _has_bit(0);
}
inline void M3ActuatorCommand::clear_tq_desired() {
  tq_desired_ = 0;
  _clear_bit(0);
}
inline double M3ActuatorCommand::tq_desired() const {
  return tq_desired_;
}
inline void M3ActuatorCommand::set_tq_desired(double value) {
  _set_bit(0);
  tq_desired_ = value;
}

// optional double pwm_desired = 3;
inline bool M3ActuatorCommand::has_pwm_desired() const {
  return _has_bit(1);
}
inline void M3ActuatorCommand::clear_pwm_desired() {
  pwm_desired_ = 0;
  _clear_bit(1);
}
inline double M3ActuatorCommand::pwm_desired() const {
  return pwm_desired_;
}
inline void M3ActuatorCommand::set_pwm_desired(double value) {
  _set_bit(1);
  pwm_desired_ = value;
}

// optional .ACTUATOR_MODE ctrl_mode = 4;
inline bool M3ActuatorCommand::has_ctrl_mode() const {
  return _has_bit(2);
}
inline void M3ActuatorCommand::clear_ctrl_mode() {
  ctrl_mode_ = 0;
  _clear_bit(2);
}
inline ACTUATOR_MODE M3ActuatorCommand::ctrl_mode() const {
  return static_cast< ACTUATOR_MODE >(ctrl_mode_);
}
inline void M3ActuatorCommand::set_ctrl_mode(ACTUATOR_MODE value) {
  GOOGLE_DCHECK(ACTUATOR_MODE_IsValid(value));
  _set_bit(2);
  ctrl_mode_ = value;
}

// optional bool brake_off = 5;
inline bool M3ActuatorCommand::has_brake_off() const {
  return _has_bit(3);
}
inline void M3ActuatorCommand::clear_brake_off() {
  brake_off_ = false;
  _clear_bit(3);
}
inline bool M3ActuatorCommand::brake_off() const {
  return brake_off_;
}
inline void M3ActuatorCommand::set_brake_off(bool value) {
  _set_bit(3);
  brake_off_ = value;
}


#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ACTUATOR_MODE>() {
  return ACTUATOR_MODE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_actuator_2eproto__INCLUDED
