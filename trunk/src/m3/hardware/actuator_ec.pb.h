// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_actuator_5fec_2eproto__INCLUDED
#define PROTOBUF_actuator_5fec_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "component_base.pb.h"

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_actuator_5fec_2eproto();
void protobuf_AssignDesc_actuator_5fec_2eproto();
void protobuf_ShutdownFile_actuator_5fec_2eproto();

class M3ActuatorEcStatus;
class M3ActuatorEcCommand;
class M3ActuatorEcParam;

enum ACTUATOR_EC_MODE {
  ACTUATOR_EC_MODE_OFF = 0,
  ACTUATOR_EC_MODE_PWM = 1,
  ACTUATOR_EC_MODE_TORQUE = 2,
  ACTUATOR_EC_MODE_CURRENT = 3
};
bool ACTUATOR_EC_MODE_IsValid(int value);
const ACTUATOR_EC_MODE ACTUATOR_EC_MODE_MIN = ACTUATOR_EC_MODE_OFF;
const ACTUATOR_EC_MODE ACTUATOR_EC_MODE_MAX = ACTUATOR_EC_MODE_CURRENT;

const ::google::protobuf::EnumDescriptor* ACTUATOR_EC_MODE_descriptor();
inline const ::std::string& ACTUATOR_EC_MODE_Name(ACTUATOR_EC_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACTUATOR_EC_MODE_descriptor(), value);
}
inline bool ACTUATOR_EC_MODE_Parse(
    const ::std::string& name, ACTUATOR_EC_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACTUATOR_EC_MODE>(
    ACTUATOR_EC_MODE_descriptor(), name, value);
}
enum ACTUATOR_EC_FLAG {
  ACTUATOR_EC_FLAG_POS_LIMITSWITCH = 1,
  ACTUATOR_EC_FLAG_NEG_LIMITSWITCH = 2,
  ACTUATOR_EC_FLAG_QEI_CALIBRATED = 4,
  ACTUATOR_EC_FLAG_AUX_SWITCH = 8,
  ACTUATOR_EC_FLAG_I_FAULT_CONT = 16,
  ACTUATOR_EC_FLAG_I_FAULT_MOM = 32
};
bool ACTUATOR_EC_FLAG_IsValid(int value);
const ACTUATOR_EC_FLAG ACTUATOR_EC_FLAG_MIN = ACTUATOR_EC_FLAG_POS_LIMITSWITCH;
const ACTUATOR_EC_FLAG ACTUATOR_EC_FLAG_MAX = ACTUATOR_EC_FLAG_I_FAULT_MOM;

const ::google::protobuf::EnumDescriptor* ACTUATOR_EC_FLAG_descriptor();
inline const ::std::string& ACTUATOR_EC_FLAG_Name(ACTUATOR_EC_FLAG value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACTUATOR_EC_FLAG_descriptor(), value);
}
inline bool ACTUATOR_EC_FLAG_Parse(
    const ::std::string& name, ACTUATOR_EC_FLAG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACTUATOR_EC_FLAG>(
    ACTUATOR_EC_FLAG_descriptor(), name, value);
}
enum ACTUATOR_EC_CONFIG {
  ACTUATOR_EC_CONFIG_TORQUE_SMOOTH = 2,
  ACTUATOR_EC_CONFIG_ENC_BOUNDS = 16,
  ACTUATOR_EC_CONFIG_PWM_FWD_SIGN = 32,
  ACTUATOR_EC_CONFIG_BRAKE_OFF = 64,
  ACTUATOR_EC_CONFIG_VERTX_FILTER_OFF = 128,
  ACTUATOR_EC_CONFIG_LIMITSWITCH_STOP_POS = 256,
  ACTUATOR_EC_CONFIG_LIMITSWITCH_STOP_NEG = 512,
  ACTUATOR_EC_CONFIG_CALIB_QEI_LIMITSWITCH_POS = 1024,
  ACTUATOR_EC_CONFIG_CALIB_QEI_LIMITSWITCH_NEG = 2048,
  ACTUATOR_EC_CONFIG_TORQUE_FF = 4096,
  ACTUATOR_EC_CONFIG_CALIB_QEI_MANUAL = 8192
};
bool ACTUATOR_EC_CONFIG_IsValid(int value);
const ACTUATOR_EC_CONFIG ACTUATOR_EC_CONFIG_MIN = ACTUATOR_EC_CONFIG_TORQUE_SMOOTH;
const ACTUATOR_EC_CONFIG ACTUATOR_EC_CONFIG_MAX = ACTUATOR_EC_CONFIG_CALIB_QEI_MANUAL;

const ::google::protobuf::EnumDescriptor* ACTUATOR_EC_CONFIG_descriptor();
inline const ::std::string& ACTUATOR_EC_CONFIG_Name(ACTUATOR_EC_CONFIG value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACTUATOR_EC_CONFIG_descriptor(), value);
}
inline bool ACTUATOR_EC_CONFIG_Parse(
    const ::std::string& name, ACTUATOR_EC_CONFIG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACTUATOR_EC_CONFIG>(
    ACTUATOR_EC_CONFIG_descriptor(), name, value);
}
// ===================================================================

class M3ActuatorEcStatus : public ::google::protobuf::Message {
 public:
  M3ActuatorEcStatus();
  virtual ~M3ActuatorEcStatus();
  
  M3ActuatorEcStatus(const M3ActuatorEcStatus& from);
  
  inline M3ActuatorEcStatus& operator=(const M3ActuatorEcStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorEcStatus& default_instance();
  void Swap(M3ActuatorEcStatus* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorEcStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorEcStatus& from);
  void MergeFrom(const M3ActuatorEcStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .M3BaseStatus base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::M3BaseStatus& base() const;
  inline ::M3BaseStatus* mutable_base();
  
  // optional .M3EtherCATStatus ethercat = 2;
  inline bool has_ethercat() const;
  inline void clear_ethercat();
  static const int kEthercatFieldNumber = 2;
  inline const ::M3EtherCATStatus& ethercat() const;
  inline ::M3EtherCATStatus* mutable_ethercat();
  
  // optional uint64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // optional int32 qei_on = 4;
  inline bool has_qei_on() const;
  inline void clear_qei_on();
  static const int kQeiOnFieldNumber = 4;
  inline ::google::protobuf::int32 qei_on() const;
  inline void set_qei_on(::google::protobuf::int32 value);
  
  // optional int32 qei_rollover = 5;
  inline bool has_qei_rollover() const;
  inline void clear_qei_rollover();
  static const int kQeiRolloverFieldNumber = 5;
  inline ::google::protobuf::int32 qei_rollover() const;
  inline void set_qei_rollover(::google::protobuf::int32 value);
  
  // optional int32 qei_period = 6;
  inline bool has_qei_period() const;
  inline void clear_qei_period();
  static const int kQeiPeriodFieldNumber = 6;
  inline ::google::protobuf::int32 qei_period() const;
  inline void set_qei_period(::google::protobuf::int32 value);
  
  // optional int32 debug = 7;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 7;
  inline ::google::protobuf::int32 debug() const;
  inline void set_debug(::google::protobuf::int32 value);
  
  // optional int32 adc_torque = 8;
  inline bool has_adc_torque() const;
  inline void clear_adc_torque();
  static const int kAdcTorqueFieldNumber = 8;
  inline ::google::protobuf::int32 adc_torque() const;
  inline void set_adc_torque(::google::protobuf::int32 value);
  
  // optional int32 adc_ext_temp = 9;
  inline bool has_adc_ext_temp() const;
  inline void clear_adc_ext_temp();
  static const int kAdcExtTempFieldNumber = 9;
  inline ::google::protobuf::int32 adc_ext_temp() const;
  inline void set_adc_ext_temp(::google::protobuf::int32 value);
  
  // optional int32 adc_amp_temp = 10;
  inline bool has_adc_amp_temp() const;
  inline void clear_adc_amp_temp();
  static const int kAdcAmpTempFieldNumber = 10;
  inline ::google::protobuf::int32 adc_amp_temp() const;
  inline void set_adc_amp_temp(::google::protobuf::int32 value);
  
  // optional int32 adc_current_a = 11;
  inline bool has_adc_current_a() const;
  inline void clear_adc_current_a();
  static const int kAdcCurrentAFieldNumber = 11;
  inline ::google::protobuf::int32 adc_current_a() const;
  inline void set_adc_current_a(::google::protobuf::int32 value);
  
  // optional int32 adc_current_b = 12;
  inline bool has_adc_current_b() const;
  inline void clear_adc_current_b();
  static const int kAdcCurrentBFieldNumber = 12;
  inline ::google::protobuf::int32 adc_current_b() const;
  inline void set_adc_current_b(::google::protobuf::int32 value);
  
  // optional int32 adc_ext_a = 13;
  inline bool has_adc_ext_a() const;
  inline void clear_adc_ext_a();
  static const int kAdcExtAFieldNumber = 13;
  inline ::google::protobuf::int32 adc_ext_a() const;
  inline void set_adc_ext_a(::google::protobuf::int32 value);
  
  // optional int32 adc_ext_b = 14;
  inline bool has_adc_ext_b() const;
  inline void clear_adc_ext_b();
  static const int kAdcExtBFieldNumber = 14;
  inline ::google::protobuf::int32 adc_ext_b() const;
  inline void set_adc_ext_b(::google::protobuf::int32 value);
  
  // optional int32 pwm_cmd = 15;
  inline bool has_pwm_cmd() const;
  inline void clear_pwm_cmd();
  static const int kPwmCmdFieldNumber = 15;
  inline ::google::protobuf::int32 pwm_cmd() const;
  inline void set_pwm_cmd(::google::protobuf::int32 value);
  
  // optional int32 flags = 16;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 16;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);
  
  // optional int32 current_ma = 17;
  inline bool has_current_ma() const;
  inline void clear_current_ma();
  static const int kCurrentMaFieldNumber = 17;
  inline ::google::protobuf::int32 current_ma() const;
  inline void set_current_ma(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::M3BaseStatus* base_;
  ::M3EtherCATStatus* ethercat_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 qei_on_;
  ::google::protobuf::int32 qei_rollover_;
  ::google::protobuf::int32 qei_period_;
  ::google::protobuf::int32 debug_;
  ::google::protobuf::int32 adc_torque_;
  ::google::protobuf::int32 adc_ext_temp_;
  ::google::protobuf::int32 adc_amp_temp_;
  ::google::protobuf::int32 adc_current_a_;
  ::google::protobuf::int32 adc_current_b_;
  ::google::protobuf::int32 adc_ext_a_;
  ::google::protobuf::int32 adc_ext_b_;
  ::google::protobuf::int32 pwm_cmd_;
  ::google::protobuf::int32 flags_;
  ::google::protobuf::int32 current_ma_;
  friend void  protobuf_AddDesc_actuator_5fec_2eproto();
  friend void protobuf_AssignDesc_actuator_5fec_2eproto();
  friend void protobuf_ShutdownFile_actuator_5fec_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static M3ActuatorEcStatus* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorEcCommand : public ::google::protobuf::Message {
 public:
  M3ActuatorEcCommand();
  virtual ~M3ActuatorEcCommand();
  
  M3ActuatorEcCommand(const M3ActuatorEcCommand& from);
  
  inline M3ActuatorEcCommand& operator=(const M3ActuatorEcCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorEcCommand& default_instance();
  void Swap(M3ActuatorEcCommand* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorEcCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorEcCommand& from);
  void MergeFrom(const M3ActuatorEcCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 t_desire = 1;
  inline bool has_t_desire() const;
  inline void clear_t_desire();
  static const int kTDesireFieldNumber = 1;
  inline ::google::protobuf::int32 t_desire() const;
  inline void set_t_desire(::google::protobuf::int32 value);
  
  // optional .ACTUATOR_EC_MODE mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ACTUATOR_EC_MODE mode() const;
  inline void set_mode(ACTUATOR_EC_MODE value);
  
  // optional bool brake_off = 3;
  inline bool has_brake_off() const;
  inline void clear_brake_off();
  static const int kBrakeOffFieldNumber = 3;
  inline bool brake_off() const;
  inline void set_brake_off(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 t_desire_;
  int mode_;
  bool brake_off_;
  friend void  protobuf_AddDesc_actuator_5fec_2eproto();
  friend void protobuf_AssignDesc_actuator_5fec_2eproto();
  friend void protobuf_ShutdownFile_actuator_5fec_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static M3ActuatorEcCommand* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorEcParam : public ::google::protobuf::Message {
 public:
  M3ActuatorEcParam();
  virtual ~M3ActuatorEcParam();
  
  M3ActuatorEcParam(const M3ActuatorEcParam& from);
  
  inline M3ActuatorEcParam& operator=(const M3ActuatorEcParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorEcParam& default_instance();
  void Swap(M3ActuatorEcParam* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorEcParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorEcParam& from);
  void MergeFrom(const M3ActuatorEcParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 config = 1;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 1;
  inline ::google::protobuf::int32 config() const;
  inline void set_config(::google::protobuf::int32 value);
  
  // optional int32 k_p = 2;
  inline bool has_k_p() const;
  inline void clear_k_p();
  static const int kKPFieldNumber = 2;
  inline ::google::protobuf::int32 k_p() const;
  inline void set_k_p(::google::protobuf::int32 value);
  
  // optional int32 k_i = 3;
  inline bool has_k_i() const;
  inline void clear_k_i();
  static const int kKIFieldNumber = 3;
  inline ::google::protobuf::int32 k_i() const;
  inline void set_k_i(::google::protobuf::int32 value);
  
  // optional int32 k_d = 4;
  inline bool has_k_d() const;
  inline void clear_k_d();
  static const int kKDFieldNumber = 4;
  inline ::google::protobuf::int32 k_d() const;
  inline void set_k_d(::google::protobuf::int32 value);
  
  // optional int32 k_p_shift = 5;
  inline bool has_k_p_shift() const;
  inline void clear_k_p_shift();
  static const int kKPShiftFieldNumber = 5;
  inline ::google::protobuf::int32 k_p_shift() const;
  inline void set_k_p_shift(::google::protobuf::int32 value);
  
  // optional int32 k_i_shift = 6;
  inline bool has_k_i_shift() const;
  inline void clear_k_i_shift();
  static const int kKIShiftFieldNumber = 6;
  inline ::google::protobuf::int32 k_i_shift() const;
  inline void set_k_i_shift(::google::protobuf::int32 value);
  
  // optional int32 k_d_shift = 7;
  inline bool has_k_d_shift() const;
  inline void clear_k_d_shift();
  static const int kKDShiftFieldNumber = 7;
  inline ::google::protobuf::int32 k_d_shift() const;
  inline void set_k_d_shift(::google::protobuf::int32 value);
  
  // optional int32 k_i_limit = 8;
  inline bool has_k_i_limit() const;
  inline void clear_k_i_limit();
  static const int kKILimitFieldNumber = 8;
  inline ::google::protobuf::int32 k_i_limit() const;
  inline void set_k_i_limit(::google::protobuf::int32 value);
  
  // optional int32 t_max = 9;
  inline bool has_t_max() const;
  inline void clear_t_max();
  static const int kTMaxFieldNumber = 9;
  inline ::google::protobuf::int32 t_max() const;
  inline void set_t_max(::google::protobuf::int32 value);
  
  // optional int32 t_min = 10;
  inline bool has_t_min() const;
  inline void clear_t_min();
  static const int kTMinFieldNumber = 10;
  inline ::google::protobuf::int32 t_min() const;
  inline void set_t_min(::google::protobuf::int32 value);
  
  // optional int32 pwm_max = 11;
  inline bool has_pwm_max() const;
  inline void clear_pwm_max();
  static const int kPwmMaxFieldNumber = 11;
  inline ::google::protobuf::int32 pwm_max() const;
  inline void set_pwm_max(::google::protobuf::int32 value);
  
  // optional int32 qei_max = 12;
  inline bool has_qei_max() const;
  inline void clear_qei_max();
  static const int kQeiMaxFieldNumber = 12;
  inline ::google::protobuf::int32 qei_max() const;
  inline void set_qei_max(::google::protobuf::int32 value);
  
  // optional int32 qei_min = 13;
  inline bool has_qei_min() const;
  inline void clear_qei_min();
  static const int kQeiMinFieldNumber = 13;
  inline ::google::protobuf::int32 qei_min() const;
  inline void set_qei_min(::google::protobuf::int32 value);
  
  // optional int32 k_ff_zero = 14;
  inline bool has_k_ff_zero() const;
  inline void clear_k_ff_zero();
  static const int kKFfZeroFieldNumber = 14;
  inline ::google::protobuf::int32 k_ff_zero() const;
  inline void set_k_ff_zero(::google::protobuf::int32 value);
  
  // optional int32 k_ff_shift = 15;
  inline bool has_k_ff_shift() const;
  inline void clear_k_ff_shift();
  static const int kKFfShiftFieldNumber = 15;
  inline ::google::protobuf::int32 k_ff_shift() const;
  inline void set_k_ff_shift(::google::protobuf::int32 value);
  
  // optional int32 k_ff = 16;
  inline bool has_k_ff() const;
  inline void clear_k_ff();
  static const int kKFfFieldNumber = 16;
  inline ::google::protobuf::int32 k_ff() const;
  inline void set_k_ff(::google::protobuf::int32 value);
  
  // optional int32 pwm_db = 17;
  inline bool has_pwm_db() const;
  inline void clear_pwm_db();
  static const int kPwmDbFieldNumber = 17;
  inline ::google::protobuf::int32 pwm_db() const;
  inline void set_pwm_db(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 config_;
  ::google::protobuf::int32 k_p_;
  ::google::protobuf::int32 k_i_;
  ::google::protobuf::int32 k_d_;
  ::google::protobuf::int32 k_p_shift_;
  ::google::protobuf::int32 k_i_shift_;
  ::google::protobuf::int32 k_d_shift_;
  ::google::protobuf::int32 k_i_limit_;
  ::google::protobuf::int32 t_max_;
  ::google::protobuf::int32 t_min_;
  ::google::protobuf::int32 pwm_max_;
  ::google::protobuf::int32 qei_max_;
  ::google::protobuf::int32 qei_min_;
  ::google::protobuf::int32 k_ff_zero_;
  ::google::protobuf::int32 k_ff_shift_;
  ::google::protobuf::int32 k_ff_;
  ::google::protobuf::int32 pwm_db_;
  friend void  protobuf_AddDesc_actuator_5fec_2eproto();
  friend void protobuf_AssignDesc_actuator_5fec_2eproto();
  friend void protobuf_ShutdownFile_actuator_5fec_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static M3ActuatorEcParam* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// M3ActuatorEcStatus

// optional .M3BaseStatus base = 1;
inline bool M3ActuatorEcStatus::has_base() const {
  return _has_bit(0);
}
inline void M3ActuatorEcStatus::clear_base() {
  if (base_ != NULL) base_->::M3BaseStatus::Clear();
  _clear_bit(0);
}
inline const ::M3BaseStatus& M3ActuatorEcStatus::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::M3BaseStatus* M3ActuatorEcStatus::mutable_base() {
  _set_bit(0);
  if (base_ == NULL) base_ = new ::M3BaseStatus;
  return base_;
}

// optional .M3EtherCATStatus ethercat = 2;
inline bool M3ActuatorEcStatus::has_ethercat() const {
  return _has_bit(1);
}
inline void M3ActuatorEcStatus::clear_ethercat() {
  if (ethercat_ != NULL) ethercat_->::M3EtherCATStatus::Clear();
  _clear_bit(1);
}
inline const ::M3EtherCATStatus& M3ActuatorEcStatus::ethercat() const {
  return ethercat_ != NULL ? *ethercat_ : *default_instance_->ethercat_;
}
inline ::M3EtherCATStatus* M3ActuatorEcStatus::mutable_ethercat() {
  _set_bit(1);
  if (ethercat_ == NULL) ethercat_ = new ::M3EtherCATStatus;
  return ethercat_;
}

// optional uint64 timestamp = 3;
inline bool M3ActuatorEcStatus::has_timestamp() const {
  return _has_bit(2);
}
inline void M3ActuatorEcStatus::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 M3ActuatorEcStatus::timestamp() const {
  return timestamp_;
}
inline void M3ActuatorEcStatus::set_timestamp(::google::protobuf::uint64 value) {
  _set_bit(2);
  timestamp_ = value;
}

// optional int32 qei_on = 4;
inline bool M3ActuatorEcStatus::has_qei_on() const {
  return _has_bit(3);
}
inline void M3ActuatorEcStatus::clear_qei_on() {
  qei_on_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::qei_on() const {
  return qei_on_;
}
inline void M3ActuatorEcStatus::set_qei_on(::google::protobuf::int32 value) {
  _set_bit(3);
  qei_on_ = value;
}

// optional int32 qei_rollover = 5;
inline bool M3ActuatorEcStatus::has_qei_rollover() const {
  return _has_bit(4);
}
inline void M3ActuatorEcStatus::clear_qei_rollover() {
  qei_rollover_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::qei_rollover() const {
  return qei_rollover_;
}
inline void M3ActuatorEcStatus::set_qei_rollover(::google::protobuf::int32 value) {
  _set_bit(4);
  qei_rollover_ = value;
}

// optional int32 qei_period = 6;
inline bool M3ActuatorEcStatus::has_qei_period() const {
  return _has_bit(5);
}
inline void M3ActuatorEcStatus::clear_qei_period() {
  qei_period_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::qei_period() const {
  return qei_period_;
}
inline void M3ActuatorEcStatus::set_qei_period(::google::protobuf::int32 value) {
  _set_bit(5);
  qei_period_ = value;
}

// optional int32 debug = 7;
inline bool M3ActuatorEcStatus::has_debug() const {
  return _has_bit(6);
}
inline void M3ActuatorEcStatus::clear_debug() {
  debug_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::debug() const {
  return debug_;
}
inline void M3ActuatorEcStatus::set_debug(::google::protobuf::int32 value) {
  _set_bit(6);
  debug_ = value;
}

// optional int32 adc_torque = 8;
inline bool M3ActuatorEcStatus::has_adc_torque() const {
  return _has_bit(7);
}
inline void M3ActuatorEcStatus::clear_adc_torque() {
  adc_torque_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::adc_torque() const {
  return adc_torque_;
}
inline void M3ActuatorEcStatus::set_adc_torque(::google::protobuf::int32 value) {
  _set_bit(7);
  adc_torque_ = value;
}

// optional int32 adc_ext_temp = 9;
inline bool M3ActuatorEcStatus::has_adc_ext_temp() const {
  return _has_bit(8);
}
inline void M3ActuatorEcStatus::clear_adc_ext_temp() {
  adc_ext_temp_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::adc_ext_temp() const {
  return adc_ext_temp_;
}
inline void M3ActuatorEcStatus::set_adc_ext_temp(::google::protobuf::int32 value) {
  _set_bit(8);
  adc_ext_temp_ = value;
}

// optional int32 adc_amp_temp = 10;
inline bool M3ActuatorEcStatus::has_adc_amp_temp() const {
  return _has_bit(9);
}
inline void M3ActuatorEcStatus::clear_adc_amp_temp() {
  adc_amp_temp_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::adc_amp_temp() const {
  return adc_amp_temp_;
}
inline void M3ActuatorEcStatus::set_adc_amp_temp(::google::protobuf::int32 value) {
  _set_bit(9);
  adc_amp_temp_ = value;
}

// optional int32 adc_current_a = 11;
inline bool M3ActuatorEcStatus::has_adc_current_a() const {
  return _has_bit(10);
}
inline void M3ActuatorEcStatus::clear_adc_current_a() {
  adc_current_a_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::adc_current_a() const {
  return adc_current_a_;
}
inline void M3ActuatorEcStatus::set_adc_current_a(::google::protobuf::int32 value) {
  _set_bit(10);
  adc_current_a_ = value;
}

// optional int32 adc_current_b = 12;
inline bool M3ActuatorEcStatus::has_adc_current_b() const {
  return _has_bit(11);
}
inline void M3ActuatorEcStatus::clear_adc_current_b() {
  adc_current_b_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::adc_current_b() const {
  return adc_current_b_;
}
inline void M3ActuatorEcStatus::set_adc_current_b(::google::protobuf::int32 value) {
  _set_bit(11);
  adc_current_b_ = value;
}

// optional int32 adc_ext_a = 13;
inline bool M3ActuatorEcStatus::has_adc_ext_a() const {
  return _has_bit(12);
}
inline void M3ActuatorEcStatus::clear_adc_ext_a() {
  adc_ext_a_ = 0;
  _clear_bit(12);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::adc_ext_a() const {
  return adc_ext_a_;
}
inline void M3ActuatorEcStatus::set_adc_ext_a(::google::protobuf::int32 value) {
  _set_bit(12);
  adc_ext_a_ = value;
}

// optional int32 adc_ext_b = 14;
inline bool M3ActuatorEcStatus::has_adc_ext_b() const {
  return _has_bit(13);
}
inline void M3ActuatorEcStatus::clear_adc_ext_b() {
  adc_ext_b_ = 0;
  _clear_bit(13);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::adc_ext_b() const {
  return adc_ext_b_;
}
inline void M3ActuatorEcStatus::set_adc_ext_b(::google::protobuf::int32 value) {
  _set_bit(13);
  adc_ext_b_ = value;
}

// optional int32 pwm_cmd = 15;
inline bool M3ActuatorEcStatus::has_pwm_cmd() const {
  return _has_bit(14);
}
inline void M3ActuatorEcStatus::clear_pwm_cmd() {
  pwm_cmd_ = 0;
  _clear_bit(14);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::pwm_cmd() const {
  return pwm_cmd_;
}
inline void M3ActuatorEcStatus::set_pwm_cmd(::google::protobuf::int32 value) {
  _set_bit(14);
  pwm_cmd_ = value;
}

// optional int32 flags = 16;
inline bool M3ActuatorEcStatus::has_flags() const {
  return _has_bit(15);
}
inline void M3ActuatorEcStatus::clear_flags() {
  flags_ = 0;
  _clear_bit(15);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::flags() const {
  return flags_;
}
inline void M3ActuatorEcStatus::set_flags(::google::protobuf::int32 value) {
  _set_bit(15);
  flags_ = value;
}

// optional int32 current_ma = 17;
inline bool M3ActuatorEcStatus::has_current_ma() const {
  return _has_bit(16);
}
inline void M3ActuatorEcStatus::clear_current_ma() {
  current_ma_ = 0;
  _clear_bit(16);
}
inline ::google::protobuf::int32 M3ActuatorEcStatus::current_ma() const {
  return current_ma_;
}
inline void M3ActuatorEcStatus::set_current_ma(::google::protobuf::int32 value) {
  _set_bit(16);
  current_ma_ = value;
}

// -------------------------------------------------------------------

// M3ActuatorEcCommand

// optional int32 t_desire = 1;
inline bool M3ActuatorEcCommand::has_t_desire() const {
  return _has_bit(0);
}
inline void M3ActuatorEcCommand::clear_t_desire() {
  t_desire_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 M3ActuatorEcCommand::t_desire() const {
  return t_desire_;
}
inline void M3ActuatorEcCommand::set_t_desire(::google::protobuf::int32 value) {
  _set_bit(0);
  t_desire_ = value;
}

// optional .ACTUATOR_EC_MODE mode = 2;
inline bool M3ActuatorEcCommand::has_mode() const {
  return _has_bit(1);
}
inline void M3ActuatorEcCommand::clear_mode() {
  mode_ = 0;
  _clear_bit(1);
}
inline ACTUATOR_EC_MODE M3ActuatorEcCommand::mode() const {
  return static_cast< ACTUATOR_EC_MODE >(mode_);
}
inline void M3ActuatorEcCommand::set_mode(ACTUATOR_EC_MODE value) {
  GOOGLE_DCHECK(ACTUATOR_EC_MODE_IsValid(value));
  _set_bit(1);
  mode_ = value;
}

// optional bool brake_off = 3;
inline bool M3ActuatorEcCommand::has_brake_off() const {
  return _has_bit(2);
}
inline void M3ActuatorEcCommand::clear_brake_off() {
  brake_off_ = false;
  _clear_bit(2);
}
inline bool M3ActuatorEcCommand::brake_off() const {
  return brake_off_;
}
inline void M3ActuatorEcCommand::set_brake_off(bool value) {
  _set_bit(2);
  brake_off_ = value;
}

// -------------------------------------------------------------------

// M3ActuatorEcParam

// optional int32 config = 1;
inline bool M3ActuatorEcParam::has_config() const {
  return _has_bit(0);
}
inline void M3ActuatorEcParam::clear_config() {
  config_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::config() const {
  return config_;
}
inline void M3ActuatorEcParam::set_config(::google::protobuf::int32 value) {
  _set_bit(0);
  config_ = value;
}

// optional int32 k_p = 2;
inline bool M3ActuatorEcParam::has_k_p() const {
  return _has_bit(1);
}
inline void M3ActuatorEcParam::clear_k_p() {
  k_p_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_p() const {
  return k_p_;
}
inline void M3ActuatorEcParam::set_k_p(::google::protobuf::int32 value) {
  _set_bit(1);
  k_p_ = value;
}

// optional int32 k_i = 3;
inline bool M3ActuatorEcParam::has_k_i() const {
  return _has_bit(2);
}
inline void M3ActuatorEcParam::clear_k_i() {
  k_i_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_i() const {
  return k_i_;
}
inline void M3ActuatorEcParam::set_k_i(::google::protobuf::int32 value) {
  _set_bit(2);
  k_i_ = value;
}

// optional int32 k_d = 4;
inline bool M3ActuatorEcParam::has_k_d() const {
  return _has_bit(3);
}
inline void M3ActuatorEcParam::clear_k_d() {
  k_d_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_d() const {
  return k_d_;
}
inline void M3ActuatorEcParam::set_k_d(::google::protobuf::int32 value) {
  _set_bit(3);
  k_d_ = value;
}

// optional int32 k_p_shift = 5;
inline bool M3ActuatorEcParam::has_k_p_shift() const {
  return _has_bit(4);
}
inline void M3ActuatorEcParam::clear_k_p_shift() {
  k_p_shift_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_p_shift() const {
  return k_p_shift_;
}
inline void M3ActuatorEcParam::set_k_p_shift(::google::protobuf::int32 value) {
  _set_bit(4);
  k_p_shift_ = value;
}

// optional int32 k_i_shift = 6;
inline bool M3ActuatorEcParam::has_k_i_shift() const {
  return _has_bit(5);
}
inline void M3ActuatorEcParam::clear_k_i_shift() {
  k_i_shift_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_i_shift() const {
  return k_i_shift_;
}
inline void M3ActuatorEcParam::set_k_i_shift(::google::protobuf::int32 value) {
  _set_bit(5);
  k_i_shift_ = value;
}

// optional int32 k_d_shift = 7;
inline bool M3ActuatorEcParam::has_k_d_shift() const {
  return _has_bit(6);
}
inline void M3ActuatorEcParam::clear_k_d_shift() {
  k_d_shift_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_d_shift() const {
  return k_d_shift_;
}
inline void M3ActuatorEcParam::set_k_d_shift(::google::protobuf::int32 value) {
  _set_bit(6);
  k_d_shift_ = value;
}

// optional int32 k_i_limit = 8;
inline bool M3ActuatorEcParam::has_k_i_limit() const {
  return _has_bit(7);
}
inline void M3ActuatorEcParam::clear_k_i_limit() {
  k_i_limit_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_i_limit() const {
  return k_i_limit_;
}
inline void M3ActuatorEcParam::set_k_i_limit(::google::protobuf::int32 value) {
  _set_bit(7);
  k_i_limit_ = value;
}

// optional int32 t_max = 9;
inline bool M3ActuatorEcParam::has_t_max() const {
  return _has_bit(8);
}
inline void M3ActuatorEcParam::clear_t_max() {
  t_max_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::t_max() const {
  return t_max_;
}
inline void M3ActuatorEcParam::set_t_max(::google::protobuf::int32 value) {
  _set_bit(8);
  t_max_ = value;
}

// optional int32 t_min = 10;
inline bool M3ActuatorEcParam::has_t_min() const {
  return _has_bit(9);
}
inline void M3ActuatorEcParam::clear_t_min() {
  t_min_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::t_min() const {
  return t_min_;
}
inline void M3ActuatorEcParam::set_t_min(::google::protobuf::int32 value) {
  _set_bit(9);
  t_min_ = value;
}

// optional int32 pwm_max = 11;
inline bool M3ActuatorEcParam::has_pwm_max() const {
  return _has_bit(10);
}
inline void M3ActuatorEcParam::clear_pwm_max() {
  pwm_max_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::pwm_max() const {
  return pwm_max_;
}
inline void M3ActuatorEcParam::set_pwm_max(::google::protobuf::int32 value) {
  _set_bit(10);
  pwm_max_ = value;
}

// optional int32 qei_max = 12;
inline bool M3ActuatorEcParam::has_qei_max() const {
  return _has_bit(11);
}
inline void M3ActuatorEcParam::clear_qei_max() {
  qei_max_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::qei_max() const {
  return qei_max_;
}
inline void M3ActuatorEcParam::set_qei_max(::google::protobuf::int32 value) {
  _set_bit(11);
  qei_max_ = value;
}

// optional int32 qei_min = 13;
inline bool M3ActuatorEcParam::has_qei_min() const {
  return _has_bit(12);
}
inline void M3ActuatorEcParam::clear_qei_min() {
  qei_min_ = 0;
  _clear_bit(12);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::qei_min() const {
  return qei_min_;
}
inline void M3ActuatorEcParam::set_qei_min(::google::protobuf::int32 value) {
  _set_bit(12);
  qei_min_ = value;
}

// optional int32 k_ff_zero = 14;
inline bool M3ActuatorEcParam::has_k_ff_zero() const {
  return _has_bit(13);
}
inline void M3ActuatorEcParam::clear_k_ff_zero() {
  k_ff_zero_ = 0;
  _clear_bit(13);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_ff_zero() const {
  return k_ff_zero_;
}
inline void M3ActuatorEcParam::set_k_ff_zero(::google::protobuf::int32 value) {
  _set_bit(13);
  k_ff_zero_ = value;
}

// optional int32 k_ff_shift = 15;
inline bool M3ActuatorEcParam::has_k_ff_shift() const {
  return _has_bit(14);
}
inline void M3ActuatorEcParam::clear_k_ff_shift() {
  k_ff_shift_ = 0;
  _clear_bit(14);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_ff_shift() const {
  return k_ff_shift_;
}
inline void M3ActuatorEcParam::set_k_ff_shift(::google::protobuf::int32 value) {
  _set_bit(14);
  k_ff_shift_ = value;
}

// optional int32 k_ff = 16;
inline bool M3ActuatorEcParam::has_k_ff() const {
  return _has_bit(15);
}
inline void M3ActuatorEcParam::clear_k_ff() {
  k_ff_ = 0;
  _clear_bit(15);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::k_ff() const {
  return k_ff_;
}
inline void M3ActuatorEcParam::set_k_ff(::google::protobuf::int32 value) {
  _set_bit(15);
  k_ff_ = value;
}

// optional int32 pwm_db = 17;
inline bool M3ActuatorEcParam::has_pwm_db() const {
  return _has_bit(16);
}
inline void M3ActuatorEcParam::clear_pwm_db() {
  pwm_db_ = 0;
  _clear_bit(16);
}
inline ::google::protobuf::int32 M3ActuatorEcParam::pwm_db() const {
  return pwm_db_;
}
inline void M3ActuatorEcParam::set_pwm_db(::google::protobuf::int32 value) {
  _set_bit(16);
  pwm_db_ = value;
}


#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ACTUATOR_EC_MODE>() {
  return ACTUATOR_EC_MODE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ACTUATOR_EC_FLAG>() {
  return ACTUATOR_EC_FLAG_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ACTUATOR_EC_CONFIG>() {
  return ACTUATOR_EC_CONFIG_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_actuator_5fec_2eproto__INCLUDED
