// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: actuator.proto

#ifndef PROTOBUF_actuator_2eproto__INCLUDED
#define PROTOBUF_actuator_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "component_base.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_actuator_2eproto();
void protobuf_AssignDesc_actuator_2eproto();
void protobuf_ShutdownFile_actuator_2eproto();

class M3ActuatorStatus;
class M3ActuatorParamPID;
class M3ActuatorParam;
class M3ActuatorCommand;

enum ACTUATOR_MODE {
  ACTUATOR_MODE_OFF = 0,
  ACTUATOR_MODE_PWM = 1,
  ACTUATOR_MODE_TORQUE = 2,
  ACTUATOR_MODE_CURRENT = 3,
  ACTUATOR_MODE_BRAKE = 4
};
bool ACTUATOR_MODE_IsValid(int value);
const ACTUATOR_MODE ACTUATOR_MODE_MIN = ACTUATOR_MODE_OFF;
const ACTUATOR_MODE ACTUATOR_MODE_MAX = ACTUATOR_MODE_BRAKE;
const int ACTUATOR_MODE_ARRAYSIZE = ACTUATOR_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACTUATOR_MODE_descriptor();
inline const ::std::string& ACTUATOR_MODE_Name(ACTUATOR_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACTUATOR_MODE_descriptor(), value);
}
inline bool ACTUATOR_MODE_Parse(
    const ::std::string& name, ACTUATOR_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACTUATOR_MODE>(
    ACTUATOR_MODE_descriptor(), name, value);
}
enum ACTUATOR_INPUT {
  ACTUATOR_INPUT_PWM = 0,
  ACTUATOR_INPUT_CURRENT = 1
};
bool ACTUATOR_INPUT_IsValid(int value);
const ACTUATOR_INPUT ACTUATOR_INPUT_MIN = ACTUATOR_INPUT_PWM;
const ACTUATOR_INPUT ACTUATOR_INPUT_MAX = ACTUATOR_INPUT_CURRENT;
const int ACTUATOR_INPUT_ARRAYSIZE = ACTUATOR_INPUT_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACTUATOR_INPUT_descriptor();
inline const ::std::string& ACTUATOR_INPUT_Name(ACTUATOR_INPUT value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACTUATOR_INPUT_descriptor(), value);
}
inline bool ACTUATOR_INPUT_Parse(
    const ::std::string& name, ACTUATOR_INPUT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACTUATOR_INPUT>(
    ACTUATOR_INPUT_descriptor(), name, value);
}
// ===================================================================

class M3ActuatorStatus : public ::google::protobuf::Message {
 public:
  M3ActuatorStatus();
  virtual ~M3ActuatorStatus();
  
  M3ActuatorStatus(const M3ActuatorStatus& from);
  
  inline M3ActuatorStatus& operator=(const M3ActuatorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorStatus& default_instance();
  
  void Swap(M3ActuatorStatus* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorStatus& from);
  void MergeFrom(const M3ActuatorStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .M3BaseStatus base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::M3BaseStatus& base() const;
  inline ::M3BaseStatus* mutable_base();
  inline ::M3BaseStatus* release_base();
  
  // optional double motor_temp = 2;
  inline bool has_motor_temp() const;
  inline void clear_motor_temp();
  static const int kMotorTempFieldNumber = 2;
  inline double motor_temp() const;
  inline void set_motor_temp(double value);
  
  // optional double amp_temp = 3;
  inline bool has_amp_temp() const;
  inline void clear_amp_temp();
  static const int kAmpTempFieldNumber = 3;
  inline double amp_temp() const;
  inline void set_amp_temp(double value);
  
  // optional double current = 4;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 4;
  inline double current() const;
  inline void set_current(double value);
  
  // optional double torque = 5;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 5;
  inline double torque() const;
  inline void set_torque(double value);
  
  // optional double torquedot = 6;
  inline bool has_torquedot() const;
  inline void clear_torquedot();
  static const int kTorquedotFieldNumber = 6;
  inline double torquedot() const;
  inline void set_torquedot(double value);
  
  // optional double theta = 7;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 7;
  inline double theta() const;
  inline void set_theta(double value);
  
  // optional double thetadot = 8;
  inline bool has_thetadot() const;
  inline void clear_thetadot();
  static const int kThetadotFieldNumber = 8;
  inline double thetadot() const;
  inline void set_thetadot(double value);
  
  // optional double thetadotdot = 9;
  inline bool has_thetadotdot() const;
  inline void clear_thetadotdot();
  static const int kThetadotdotFieldNumber = 9;
  inline double thetadotdot() const;
  inline void set_thetadotdot(double value);
  
  // optional double torque_error = 10;
  inline bool has_torque_error() const;
  inline void clear_torque_error();
  static const int kTorqueErrorFieldNumber = 10;
  inline double torque_error() const;
  inline void set_torque_error(double value);
  
  // optional int32 pwm_cmd = 11;
  inline bool has_pwm_cmd() const;
  inline void clear_pwm_cmd();
  static const int kPwmCmdFieldNumber = 11;
  inline ::google::protobuf::int32 pwm_cmd() const;
  inline void set_pwm_cmd(::google::protobuf::int32 value);
  
  // optional double ambient_temp = 12;
  inline bool has_ambient_temp() const;
  inline void clear_ambient_temp();
  static const int kAmbientTempFieldNumber = 12;
  inline double ambient_temp() const;
  inline void set_ambient_temp(double value);
  
  // optional double case_temp = 13;
  inline bool has_case_temp() const;
  inline void clear_case_temp();
  static const int kCaseTempFieldNumber = 13;
  inline double case_temp() const;
  inline void set_case_temp(double value);
  
  // optional double power = 14;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 14;
  inline double power() const;
  inline void set_power(double value);
  
  // optional int32 flags = 15;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 15;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);
  
  // optional double ext_temp = 16;
  inline bool has_ext_temp() const;
  inline void clear_ext_temp();
  static const int kExtTempFieldNumber = 16;
  inline double ext_temp() const;
  inline void set_ext_temp(double value);
  
  // optional double tq_cmd = 17;
  inline bool has_tq_cmd() const;
  inline void clear_tq_cmd();
  static const int kTqCmdFieldNumber = 17;
  inline double tq_cmd() const;
  inline void set_tq_cmd(double value);
  
  // optional double i_cmd = 18;
  inline bool has_i_cmd() const;
  inline void clear_i_cmd();
  static const int kICmdFieldNumber = 18;
  inline double i_cmd() const;
  inline void set_i_cmd(double value);
  
  // optional double mode_cmd = 19;
  inline bool has_mode_cmd() const;
  inline void clear_mode_cmd();
  static const int kModeCmdFieldNumber = 19;
  inline double mode_cmd() const;
  inline void set_mode_cmd(double value);
  
  // @@protoc_insertion_point(class_scope:M3ActuatorStatus)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_motor_temp();
  inline void clear_has_motor_temp();
  inline void set_has_amp_temp();
  inline void clear_has_amp_temp();
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_torque();
  inline void clear_has_torque();
  inline void set_has_torquedot();
  inline void clear_has_torquedot();
  inline void set_has_theta();
  inline void clear_has_theta();
  inline void set_has_thetadot();
  inline void clear_has_thetadot();
  inline void set_has_thetadotdot();
  inline void clear_has_thetadotdot();
  inline void set_has_torque_error();
  inline void clear_has_torque_error();
  inline void set_has_pwm_cmd();
  inline void clear_has_pwm_cmd();
  inline void set_has_ambient_temp();
  inline void clear_has_ambient_temp();
  inline void set_has_case_temp();
  inline void clear_has_case_temp();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_ext_temp();
  inline void clear_has_ext_temp();
  inline void set_has_tq_cmd();
  inline void clear_has_tq_cmd();
  inline void set_has_i_cmd();
  inline void clear_has_i_cmd();
  inline void set_has_mode_cmd();
  inline void clear_has_mode_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::M3BaseStatus* base_;
  double motor_temp_;
  double amp_temp_;
  double current_;
  double torque_;
  double torquedot_;
  double theta_;
  double thetadot_;
  double thetadotdot_;
  double torque_error_;
  double ambient_temp_;
  double case_temp_;
  ::google::protobuf::int32 pwm_cmd_;
  ::google::protobuf::int32 flags_;
  double power_;
  double ext_temp_;
  double tq_cmd_;
  double i_cmd_;
  double mode_cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];
  
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();
  
  void InitAsDefaultInstance();
  static M3ActuatorStatus* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorParamPID : public ::google::protobuf::Message {
 public:
  M3ActuatorParamPID();
  virtual ~M3ActuatorParamPID();
  
  M3ActuatorParamPID(const M3ActuatorParamPID& from);
  
  inline M3ActuatorParamPID& operator=(const M3ActuatorParamPID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorParamPID& default_instance();
  
  void Swap(M3ActuatorParamPID* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorParamPID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorParamPID& from);
  void MergeFrom(const M3ActuatorParamPID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double k_p = 1;
  inline bool has_k_p() const;
  inline void clear_k_p();
  static const int kKPFieldNumber = 1;
  inline double k_p() const;
  inline void set_k_p(double value);
  
  // optional double k_i = 2;
  inline bool has_k_i() const;
  inline void clear_k_i();
  static const int kKIFieldNumber = 2;
  inline double k_i() const;
  inline void set_k_i(double value);
  
  // optional double k_d = 3;
  inline bool has_k_d() const;
  inline void clear_k_d();
  static const int kKDFieldNumber = 3;
  inline double k_d() const;
  inline void set_k_d(double value);
  
  // optional double k_i_limit = 4;
  inline bool has_k_i_limit() const;
  inline void clear_k_i_limit();
  static const int kKILimitFieldNumber = 4;
  inline double k_i_limit() const;
  inline void set_k_i_limit(double value);
  
  // optional double k_i_range = 5;
  inline bool has_k_i_range() const;
  inline void clear_k_i_range();
  static const int kKIRangeFieldNumber = 5;
  inline double k_i_range() const;
  inline void set_k_i_range(double value);
  
  // @@protoc_insertion_point(class_scope:M3ActuatorParamPID)
 private:
  inline void set_has_k_p();
  inline void clear_has_k_p();
  inline void set_has_k_i();
  inline void clear_has_k_i();
  inline void set_has_k_d();
  inline void clear_has_k_d();
  inline void set_has_k_i_limit();
  inline void clear_has_k_i_limit();
  inline void set_has_k_i_range();
  inline void clear_has_k_i_range();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double k_p_;
  double k_i_;
  double k_d_;
  double k_i_limit_;
  double k_i_range_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();
  
  void InitAsDefaultInstance();
  static M3ActuatorParamPID* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorParam : public ::google::protobuf::Message {
 public:
  M3ActuatorParam();
  virtual ~M3ActuatorParam();
  
  M3ActuatorParam(const M3ActuatorParam& from);
  
  inline M3ActuatorParam& operator=(const M3ActuatorParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorParam& default_instance();
  
  void Swap(M3ActuatorParam* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorParam& from);
  void MergeFrom(const M3ActuatorParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double max_tq = 1;
  inline bool has_max_tq() const;
  inline void clear_max_tq();
  static const int kMaxTqFieldNumber = 1;
  inline double max_tq() const;
  inline void set_max_tq(double value);
  
  // optional double min_tq = 2;
  inline bool has_min_tq() const;
  inline void clear_min_tq();
  static const int kMinTqFieldNumber = 2;
  inline double min_tq() const;
  inline void set_min_tq(double value);
  
  // optional double max_i = 3;
  inline bool has_max_i() const;
  inline void clear_max_i();
  static const int kMaxIFieldNumber = 3;
  inline double max_i() const;
  inline void set_max_i(double value);
  
  // optional double max_amp_current = 4;
  inline bool has_max_amp_current() const;
  inline void clear_max_amp_current();
  static const int kMaxAmpCurrentFieldNumber = 4;
  inline double max_amp_current() const;
  inline void set_max_amp_current(double value);
  
  // optional double max_overload_time = 5;
  inline bool has_max_overload_time() const;
  inline void clear_max_overload_time();
  static const int kMaxOverloadTimeFieldNumber = 5;
  inline double max_overload_time() const;
  inline void set_max_overload_time(double value);
  
  // optional double max_amp_temp = 6;
  inline bool has_max_amp_temp() const;
  inline void clear_max_amp_temp();
  static const int kMaxAmpTempFieldNumber = 6;
  inline double max_amp_temp() const;
  inline void set_max_amp_temp(double value);
  
  // optional .M3ActuatorParamPID pid_torque = 7;
  inline bool has_pid_torque() const;
  inline void clear_pid_torque();
  static const int kPidTorqueFieldNumber = 7;
  inline const ::M3ActuatorParamPID& pid_torque() const;
  inline ::M3ActuatorParamPID* mutable_pid_torque();
  inline ::M3ActuatorParamPID* release_pid_torque();
  
  // @@protoc_insertion_point(class_scope:M3ActuatorParam)
 private:
  inline void set_has_max_tq();
  inline void clear_has_max_tq();
  inline void set_has_min_tq();
  inline void clear_has_min_tq();
  inline void set_has_max_i();
  inline void clear_has_max_i();
  inline void set_has_max_amp_current();
  inline void clear_has_max_amp_current();
  inline void set_has_max_overload_time();
  inline void clear_has_max_overload_time();
  inline void set_has_max_amp_temp();
  inline void clear_has_max_amp_temp();
  inline void set_has_pid_torque();
  inline void clear_has_pid_torque();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double max_tq_;
  double min_tq_;
  double max_i_;
  double max_amp_current_;
  double max_overload_time_;
  double max_amp_temp_;
  ::M3ActuatorParamPID* pid_torque_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();
  
  void InitAsDefaultInstance();
  static M3ActuatorParam* default_instance_;
};
// -------------------------------------------------------------------

class M3ActuatorCommand : public ::google::protobuf::Message {
 public:
  M3ActuatorCommand();
  virtual ~M3ActuatorCommand();
  
  M3ActuatorCommand(const M3ActuatorCommand& from);
  
  inline M3ActuatorCommand& operator=(const M3ActuatorCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const M3ActuatorCommand& default_instance();
  
  void Swap(M3ActuatorCommand* other);
  
  // implements Message ----------------------------------------------
  
  M3ActuatorCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const M3ActuatorCommand& from);
  void MergeFrom(const M3ActuatorCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 pwm_desired = 1;
  inline bool has_pwm_desired() const;
  inline void clear_pwm_desired();
  static const int kPwmDesiredFieldNumber = 1;
  inline ::google::protobuf::int32 pwm_desired() const;
  inline void set_pwm_desired(::google::protobuf::int32 value);
  
  // optional double tq_desired = 2;
  inline bool has_tq_desired() const;
  inline void clear_tq_desired();
  static const int kTqDesiredFieldNumber = 2;
  inline double tq_desired() const;
  inline void set_tq_desired(double value);
  
  // optional double i_desired = 3;
  inline bool has_i_desired() const;
  inline void clear_i_desired();
  static const int kIDesiredFieldNumber = 3;
  inline double i_desired() const;
  inline void set_i_desired(double value);
  
  // optional .ACTUATOR_MODE ctrl_mode = 4;
  inline bool has_ctrl_mode() const;
  inline void clear_ctrl_mode();
  static const int kCtrlModeFieldNumber = 4;
  inline ACTUATOR_MODE ctrl_mode() const;
  inline void set_ctrl_mode(ACTUATOR_MODE value);
  
  // optional bool brake_off = 5;
  inline bool has_brake_off() const;
  inline void clear_brake_off();
  static const int kBrakeOffFieldNumber = 5;
  inline bool brake_off() const;
  inline void set_brake_off(bool value);
  
  // @@protoc_insertion_point(class_scope:M3ActuatorCommand)
 private:
  inline void set_has_pwm_desired();
  inline void clear_has_pwm_desired();
  inline void set_has_tq_desired();
  inline void clear_has_tq_desired();
  inline void set_has_i_desired();
  inline void clear_has_i_desired();
  inline void set_has_ctrl_mode();
  inline void clear_has_ctrl_mode();
  inline void set_has_brake_off();
  inline void clear_has_brake_off();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double tq_desired_;
  ::google::protobuf::int32 pwm_desired_;
  int ctrl_mode_;
  double i_desired_;
  bool brake_off_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_actuator_2eproto();
  friend void protobuf_AssignDesc_actuator_2eproto();
  friend void protobuf_ShutdownFile_actuator_2eproto();
  
  void InitAsDefaultInstance();
  static M3ActuatorCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// M3ActuatorStatus

// optional .M3BaseStatus base = 1;
inline bool M3ActuatorStatus::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorStatus::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorStatus::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorStatus::clear_base() {
  if (base_ != NULL) base_->::M3BaseStatus::Clear();
  clear_has_base();
}
inline const ::M3BaseStatus& M3ActuatorStatus::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::M3BaseStatus* M3ActuatorStatus::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::M3BaseStatus;
  return base_;
}
inline ::M3BaseStatus* M3ActuatorStatus::release_base() {
  clear_has_base();
  ::M3BaseStatus* temp = base_;
  base_ = NULL;
  return temp;
}

// optional double motor_temp = 2;
inline bool M3ActuatorStatus::has_motor_temp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorStatus::set_has_motor_temp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorStatus::clear_has_motor_temp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorStatus::clear_motor_temp() {
  motor_temp_ = 0;
  clear_has_motor_temp();
}
inline double M3ActuatorStatus::motor_temp() const {
  return motor_temp_;
}
inline void M3ActuatorStatus::set_motor_temp(double value) {
  set_has_motor_temp();
  motor_temp_ = value;
}

// optional double amp_temp = 3;
inline bool M3ActuatorStatus::has_amp_temp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorStatus::set_has_amp_temp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorStatus::clear_has_amp_temp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorStatus::clear_amp_temp() {
  amp_temp_ = 0;
  clear_has_amp_temp();
}
inline double M3ActuatorStatus::amp_temp() const {
  return amp_temp_;
}
inline void M3ActuatorStatus::set_amp_temp(double value) {
  set_has_amp_temp();
  amp_temp_ = value;
}

// optional double current = 4;
inline bool M3ActuatorStatus::has_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ActuatorStatus::set_has_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ActuatorStatus::clear_has_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ActuatorStatus::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline double M3ActuatorStatus::current() const {
  return current_;
}
inline void M3ActuatorStatus::set_current(double value) {
  set_has_current();
  current_ = value;
}

// optional double torque = 5;
inline bool M3ActuatorStatus::has_torque() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ActuatorStatus::set_has_torque() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ActuatorStatus::clear_has_torque() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ActuatorStatus::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline double M3ActuatorStatus::torque() const {
  return torque_;
}
inline void M3ActuatorStatus::set_torque(double value) {
  set_has_torque();
  torque_ = value;
}

// optional double torquedot = 6;
inline bool M3ActuatorStatus::has_torquedot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3ActuatorStatus::set_has_torquedot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3ActuatorStatus::clear_has_torquedot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3ActuatorStatus::clear_torquedot() {
  torquedot_ = 0;
  clear_has_torquedot();
}
inline double M3ActuatorStatus::torquedot() const {
  return torquedot_;
}
inline void M3ActuatorStatus::set_torquedot(double value) {
  set_has_torquedot();
  torquedot_ = value;
}

// optional double theta = 7;
inline bool M3ActuatorStatus::has_theta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void M3ActuatorStatus::set_has_theta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void M3ActuatorStatus::clear_has_theta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void M3ActuatorStatus::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double M3ActuatorStatus::theta() const {
  return theta_;
}
inline void M3ActuatorStatus::set_theta(double value) {
  set_has_theta();
  theta_ = value;
}

// optional double thetadot = 8;
inline bool M3ActuatorStatus::has_thetadot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void M3ActuatorStatus::set_has_thetadot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void M3ActuatorStatus::clear_has_thetadot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void M3ActuatorStatus::clear_thetadot() {
  thetadot_ = 0;
  clear_has_thetadot();
}
inline double M3ActuatorStatus::thetadot() const {
  return thetadot_;
}
inline void M3ActuatorStatus::set_thetadot(double value) {
  set_has_thetadot();
  thetadot_ = value;
}

// optional double thetadotdot = 9;
inline bool M3ActuatorStatus::has_thetadotdot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void M3ActuatorStatus::set_has_thetadotdot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void M3ActuatorStatus::clear_has_thetadotdot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void M3ActuatorStatus::clear_thetadotdot() {
  thetadotdot_ = 0;
  clear_has_thetadotdot();
}
inline double M3ActuatorStatus::thetadotdot() const {
  return thetadotdot_;
}
inline void M3ActuatorStatus::set_thetadotdot(double value) {
  set_has_thetadotdot();
  thetadotdot_ = value;
}

// optional double torque_error = 10;
inline bool M3ActuatorStatus::has_torque_error() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void M3ActuatorStatus::set_has_torque_error() {
  _has_bits_[0] |= 0x00000200u;
}
inline void M3ActuatorStatus::clear_has_torque_error() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void M3ActuatorStatus::clear_torque_error() {
  torque_error_ = 0;
  clear_has_torque_error();
}
inline double M3ActuatorStatus::torque_error() const {
  return torque_error_;
}
inline void M3ActuatorStatus::set_torque_error(double value) {
  set_has_torque_error();
  torque_error_ = value;
}

// optional int32 pwm_cmd = 11;
inline bool M3ActuatorStatus::has_pwm_cmd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void M3ActuatorStatus::set_has_pwm_cmd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void M3ActuatorStatus::clear_has_pwm_cmd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void M3ActuatorStatus::clear_pwm_cmd() {
  pwm_cmd_ = 0;
  clear_has_pwm_cmd();
}
inline ::google::protobuf::int32 M3ActuatorStatus::pwm_cmd() const {
  return pwm_cmd_;
}
inline void M3ActuatorStatus::set_pwm_cmd(::google::protobuf::int32 value) {
  set_has_pwm_cmd();
  pwm_cmd_ = value;
}

// optional double ambient_temp = 12;
inline bool M3ActuatorStatus::has_ambient_temp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void M3ActuatorStatus::set_has_ambient_temp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void M3ActuatorStatus::clear_has_ambient_temp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void M3ActuatorStatus::clear_ambient_temp() {
  ambient_temp_ = 0;
  clear_has_ambient_temp();
}
inline double M3ActuatorStatus::ambient_temp() const {
  return ambient_temp_;
}
inline void M3ActuatorStatus::set_ambient_temp(double value) {
  set_has_ambient_temp();
  ambient_temp_ = value;
}

// optional double case_temp = 13;
inline bool M3ActuatorStatus::has_case_temp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void M3ActuatorStatus::set_has_case_temp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void M3ActuatorStatus::clear_has_case_temp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void M3ActuatorStatus::clear_case_temp() {
  case_temp_ = 0;
  clear_has_case_temp();
}
inline double M3ActuatorStatus::case_temp() const {
  return case_temp_;
}
inline void M3ActuatorStatus::set_case_temp(double value) {
  set_has_case_temp();
  case_temp_ = value;
}

// optional double power = 14;
inline bool M3ActuatorStatus::has_power() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void M3ActuatorStatus::set_has_power() {
  _has_bits_[0] |= 0x00002000u;
}
inline void M3ActuatorStatus::clear_has_power() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void M3ActuatorStatus::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline double M3ActuatorStatus::power() const {
  return power_;
}
inline void M3ActuatorStatus::set_power(double value) {
  set_has_power();
  power_ = value;
}

// optional int32 flags = 15;
inline bool M3ActuatorStatus::has_flags() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void M3ActuatorStatus::set_has_flags() {
  _has_bits_[0] |= 0x00004000u;
}
inline void M3ActuatorStatus::clear_has_flags() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void M3ActuatorStatus::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 M3ActuatorStatus::flags() const {
  return flags_;
}
inline void M3ActuatorStatus::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
}

// optional double ext_temp = 16;
inline bool M3ActuatorStatus::has_ext_temp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void M3ActuatorStatus::set_has_ext_temp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void M3ActuatorStatus::clear_has_ext_temp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void M3ActuatorStatus::clear_ext_temp() {
  ext_temp_ = 0;
  clear_has_ext_temp();
}
inline double M3ActuatorStatus::ext_temp() const {
  return ext_temp_;
}
inline void M3ActuatorStatus::set_ext_temp(double value) {
  set_has_ext_temp();
  ext_temp_ = value;
}

// optional double tq_cmd = 17;
inline bool M3ActuatorStatus::has_tq_cmd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void M3ActuatorStatus::set_has_tq_cmd() {
  _has_bits_[0] |= 0x00010000u;
}
inline void M3ActuatorStatus::clear_has_tq_cmd() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void M3ActuatorStatus::clear_tq_cmd() {
  tq_cmd_ = 0;
  clear_has_tq_cmd();
}
inline double M3ActuatorStatus::tq_cmd() const {
  return tq_cmd_;
}
inline void M3ActuatorStatus::set_tq_cmd(double value) {
  set_has_tq_cmd();
  tq_cmd_ = value;
}

// optional double i_cmd = 18;
inline bool M3ActuatorStatus::has_i_cmd() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void M3ActuatorStatus::set_has_i_cmd() {
  _has_bits_[0] |= 0x00020000u;
}
inline void M3ActuatorStatus::clear_has_i_cmd() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void M3ActuatorStatus::clear_i_cmd() {
  i_cmd_ = 0;
  clear_has_i_cmd();
}
inline double M3ActuatorStatus::i_cmd() const {
  return i_cmd_;
}
inline void M3ActuatorStatus::set_i_cmd(double value) {
  set_has_i_cmd();
  i_cmd_ = value;
}

// optional double mode_cmd = 19;
inline bool M3ActuatorStatus::has_mode_cmd() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void M3ActuatorStatus::set_has_mode_cmd() {
  _has_bits_[0] |= 0x00040000u;
}
inline void M3ActuatorStatus::clear_has_mode_cmd() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void M3ActuatorStatus::clear_mode_cmd() {
  mode_cmd_ = 0;
  clear_has_mode_cmd();
}
inline double M3ActuatorStatus::mode_cmd() const {
  return mode_cmd_;
}
inline void M3ActuatorStatus::set_mode_cmd(double value) {
  set_has_mode_cmd();
  mode_cmd_ = value;
}

// -------------------------------------------------------------------

// M3ActuatorParamPID

// optional double k_p = 1;
inline bool M3ActuatorParamPID::has_k_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorParamPID::clear_has_k_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorParamPID::clear_k_p() {
  k_p_ = 0;
  clear_has_k_p();
}
inline double M3ActuatorParamPID::k_p() const {
  return k_p_;
}
inline void M3ActuatorParamPID::set_k_p(double value) {
  set_has_k_p();
  k_p_ = value;
}

// optional double k_i = 2;
inline bool M3ActuatorParamPID::has_k_i() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_i() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorParamPID::clear_has_k_i() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorParamPID::clear_k_i() {
  k_i_ = 0;
  clear_has_k_i();
}
inline double M3ActuatorParamPID::k_i() const {
  return k_i_;
}
inline void M3ActuatorParamPID::set_k_i(double value) {
  set_has_k_i();
  k_i_ = value;
}

// optional double k_d = 3;
inline bool M3ActuatorParamPID::has_k_d() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_d() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorParamPID::clear_has_k_d() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorParamPID::clear_k_d() {
  k_d_ = 0;
  clear_has_k_d();
}
inline double M3ActuatorParamPID::k_d() const {
  return k_d_;
}
inline void M3ActuatorParamPID::set_k_d(double value) {
  set_has_k_d();
  k_d_ = value;
}

// optional double k_i_limit = 4;
inline bool M3ActuatorParamPID::has_k_i_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_i_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ActuatorParamPID::clear_has_k_i_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ActuatorParamPID::clear_k_i_limit() {
  k_i_limit_ = 0;
  clear_has_k_i_limit();
}
inline double M3ActuatorParamPID::k_i_limit() const {
  return k_i_limit_;
}
inline void M3ActuatorParamPID::set_k_i_limit(double value) {
  set_has_k_i_limit();
  k_i_limit_ = value;
}

// optional double k_i_range = 5;
inline bool M3ActuatorParamPID::has_k_i_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ActuatorParamPID::set_has_k_i_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ActuatorParamPID::clear_has_k_i_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ActuatorParamPID::clear_k_i_range() {
  k_i_range_ = 0;
  clear_has_k_i_range();
}
inline double M3ActuatorParamPID::k_i_range() const {
  return k_i_range_;
}
inline void M3ActuatorParamPID::set_k_i_range(double value) {
  set_has_k_i_range();
  k_i_range_ = value;
}

// -------------------------------------------------------------------

// M3ActuatorParam

// optional double max_tq = 1;
inline bool M3ActuatorParam::has_max_tq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorParam::set_has_max_tq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorParam::clear_has_max_tq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorParam::clear_max_tq() {
  max_tq_ = 0;
  clear_has_max_tq();
}
inline double M3ActuatorParam::max_tq() const {
  return max_tq_;
}
inline void M3ActuatorParam::set_max_tq(double value) {
  set_has_max_tq();
  max_tq_ = value;
}

// optional double min_tq = 2;
inline bool M3ActuatorParam::has_min_tq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorParam::set_has_min_tq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorParam::clear_has_min_tq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorParam::clear_min_tq() {
  min_tq_ = 0;
  clear_has_min_tq();
}
inline double M3ActuatorParam::min_tq() const {
  return min_tq_;
}
inline void M3ActuatorParam::set_min_tq(double value) {
  set_has_min_tq();
  min_tq_ = value;
}

// optional double max_i = 3;
inline bool M3ActuatorParam::has_max_i() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorParam::set_has_max_i() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorParam::clear_has_max_i() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorParam::clear_max_i() {
  max_i_ = 0;
  clear_has_max_i();
}
inline double M3ActuatorParam::max_i() const {
  return max_i_;
}
inline void M3ActuatorParam::set_max_i(double value) {
  set_has_max_i();
  max_i_ = value;
}

// optional double max_amp_current = 4;
inline bool M3ActuatorParam::has_max_amp_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ActuatorParam::set_has_max_amp_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ActuatorParam::clear_has_max_amp_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ActuatorParam::clear_max_amp_current() {
  max_amp_current_ = 0;
  clear_has_max_amp_current();
}
inline double M3ActuatorParam::max_amp_current() const {
  return max_amp_current_;
}
inline void M3ActuatorParam::set_max_amp_current(double value) {
  set_has_max_amp_current();
  max_amp_current_ = value;
}

// optional double max_overload_time = 5;
inline bool M3ActuatorParam::has_max_overload_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ActuatorParam::set_has_max_overload_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ActuatorParam::clear_has_max_overload_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ActuatorParam::clear_max_overload_time() {
  max_overload_time_ = 0;
  clear_has_max_overload_time();
}
inline double M3ActuatorParam::max_overload_time() const {
  return max_overload_time_;
}
inline void M3ActuatorParam::set_max_overload_time(double value) {
  set_has_max_overload_time();
  max_overload_time_ = value;
}

// optional double max_amp_temp = 6;
inline bool M3ActuatorParam::has_max_amp_temp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void M3ActuatorParam::set_has_max_amp_temp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void M3ActuatorParam::clear_has_max_amp_temp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void M3ActuatorParam::clear_max_amp_temp() {
  max_amp_temp_ = 0;
  clear_has_max_amp_temp();
}
inline double M3ActuatorParam::max_amp_temp() const {
  return max_amp_temp_;
}
inline void M3ActuatorParam::set_max_amp_temp(double value) {
  set_has_max_amp_temp();
  max_amp_temp_ = value;
}

// optional .M3ActuatorParamPID pid_torque = 7;
inline bool M3ActuatorParam::has_pid_torque() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void M3ActuatorParam::set_has_pid_torque() {
  _has_bits_[0] |= 0x00000040u;
}
inline void M3ActuatorParam::clear_has_pid_torque() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void M3ActuatorParam::clear_pid_torque() {
  if (pid_torque_ != NULL) pid_torque_->::M3ActuatorParamPID::Clear();
  clear_has_pid_torque();
}
inline const ::M3ActuatorParamPID& M3ActuatorParam::pid_torque() const {
  return pid_torque_ != NULL ? *pid_torque_ : *default_instance_->pid_torque_;
}
inline ::M3ActuatorParamPID* M3ActuatorParam::mutable_pid_torque() {
  set_has_pid_torque();
  if (pid_torque_ == NULL) pid_torque_ = new ::M3ActuatorParamPID;
  return pid_torque_;
}
inline ::M3ActuatorParamPID* M3ActuatorParam::release_pid_torque() {
  clear_has_pid_torque();
  ::M3ActuatorParamPID* temp = pid_torque_;
  pid_torque_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// M3ActuatorCommand

// optional int32 pwm_desired = 1;
inline bool M3ActuatorCommand::has_pwm_desired() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void M3ActuatorCommand::set_has_pwm_desired() {
  _has_bits_[0] |= 0x00000001u;
}
inline void M3ActuatorCommand::clear_has_pwm_desired() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void M3ActuatorCommand::clear_pwm_desired() {
  pwm_desired_ = 0;
  clear_has_pwm_desired();
}
inline ::google::protobuf::int32 M3ActuatorCommand::pwm_desired() const {
  return pwm_desired_;
}
inline void M3ActuatorCommand::set_pwm_desired(::google::protobuf::int32 value) {
  set_has_pwm_desired();
  pwm_desired_ = value;
}

// optional double tq_desired = 2;
inline bool M3ActuatorCommand::has_tq_desired() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void M3ActuatorCommand::set_has_tq_desired() {
  _has_bits_[0] |= 0x00000002u;
}
inline void M3ActuatorCommand::clear_has_tq_desired() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void M3ActuatorCommand::clear_tq_desired() {
  tq_desired_ = 0;
  clear_has_tq_desired();
}
inline double M3ActuatorCommand::tq_desired() const {
  return tq_desired_;
}
inline void M3ActuatorCommand::set_tq_desired(double value) {
  set_has_tq_desired();
  tq_desired_ = value;
}

// optional double i_desired = 3;
inline bool M3ActuatorCommand::has_i_desired() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void M3ActuatorCommand::set_has_i_desired() {
  _has_bits_[0] |= 0x00000004u;
}
inline void M3ActuatorCommand::clear_has_i_desired() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void M3ActuatorCommand::clear_i_desired() {
  i_desired_ = 0;
  clear_has_i_desired();
}
inline double M3ActuatorCommand::i_desired() const {
  return i_desired_;
}
inline void M3ActuatorCommand::set_i_desired(double value) {
  set_has_i_desired();
  i_desired_ = value;
}

// optional .ACTUATOR_MODE ctrl_mode = 4;
inline bool M3ActuatorCommand::has_ctrl_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void M3ActuatorCommand::set_has_ctrl_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void M3ActuatorCommand::clear_has_ctrl_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void M3ActuatorCommand::clear_ctrl_mode() {
  ctrl_mode_ = 0;
  clear_has_ctrl_mode();
}
inline ACTUATOR_MODE M3ActuatorCommand::ctrl_mode() const {
  return static_cast< ACTUATOR_MODE >(ctrl_mode_);
}
inline void M3ActuatorCommand::set_ctrl_mode(ACTUATOR_MODE value) {
  GOOGLE_DCHECK(ACTUATOR_MODE_IsValid(value));
  set_has_ctrl_mode();
  ctrl_mode_ = value;
}

// optional bool brake_off = 5;
inline bool M3ActuatorCommand::has_brake_off() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void M3ActuatorCommand::set_has_brake_off() {
  _has_bits_[0] |= 0x00000010u;
}
inline void M3ActuatorCommand::clear_has_brake_off() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void M3ActuatorCommand::clear_brake_off() {
  brake_off_ = false;
  clear_has_brake_off();
}
inline bool M3ActuatorCommand::brake_off() const {
  return brake_off_;
}
inline void M3ActuatorCommand::set_brake_off(bool value) {
  set_has_brake_off();
  brake_off_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ACTUATOR_MODE>() {
  return ACTUATOR_MODE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ACTUATOR_INPUT>() {
  return ACTUATOR_INPUT_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_actuator_2eproto__INCLUDED
